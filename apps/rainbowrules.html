<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Rainbow Rules</title>
<style>
  :root { --bg:#0b1220; --panel:#121a2c; --ink:#e8eefc; --muted:#93a3c9; --bd:rgba(255,255,255,.08);
          --ok:#34d399; --err:#fb7185; }
  *{box-sizing:border-box} html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto}
  .wrap{max-width:560px;margin:0 auto;padding:16px 16px 24px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
  h1{margin:0;font-size:20px}
  .stats{display:flex;gap:8px;align-items:center;flex-wrap:wrap}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border:1px solid var(--bd);border-radius:999px;background:#0e1729}
  .pill strong{font-weight:800}
  .panel{background:var(--panel);border:1px solid var(--bd);border-radius:16px;padding:12px}
  .banner{height:24px;text-align:center;font-size:14px;color:var(--muted)}
  .banner.show{color:#e8eefc}
  .grid{display:grid;grid-template-columns:repeat(4,1fr);gap:10px;margin:12px 0}
  .cell{height:76px;border-radius:14px;border:1px solid var(--bd);display:flex;align-items:center;justify-content:center;
        font-weight:800;font-size:22px;color:#0b1220; cursor:pointer; user-select:none; transition:transform .05s ease, filter .1s}
  .cell:active{transform:scale(.98)}
  .cell.off{filter:grayscale(0.3) brightness(0.65)}
  .foot{display:flex;gap:10px;justify-content:center;margin-top:8px}
  button{padding:10px 14px;border-radius:12px;border:1px solid var(--bd);background:#0e1729;color:#e8eefc;cursor:pointer;font:inherit}
  button:hover{background:#0f1a2f}
  .toast{height:22px;text-align:center;font-size:14px;color:var(--muted);margin-top:6px}
  .toast.ok{color:var(--ok)} .toast.err{color:var(--err)}
  @media (min-width:560px){ .cell{height:96px;font-size:24px} }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Rainbow Rules</h1>
    <div class="stats">
      <span class="pill">Level <strong id="level">1</strong></span>
      <span class="pill">Best <strong id="best">0</strong></span>
      <span class="pill">Global <strong id="global">0</strong></span>
    </div>
  </header>

  <div class="panel">
    <div id="banner" class="banner">Memorize the new rule…</div>
    <div id="grid" class="grid" role="group" aria-label="tile grid"></div>
    <div class="foot">
      <button id="restart">Restart</button>
      <button id="next">New</button>
    </div>
    <div id="toast" class="toast" aria-live="polite"></div>
  </div>

  <p class="pill" style="margin-top:12px; display:inline-flex">Tip: rules apply from newest ➜ oldest.</p>
</div>

<!-- Supabase for global best -->
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
<script>
(function(){
  // --- Supabase project (reuse yours) ---
  const SUPABASE_URL  = "https://fimsbfcvavpehryvvcho.supabase.co";
  const SUPABASE_ANON = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpbXNiZmN2YXZwZWhyeXZ2Y2hvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzOTEwMDMsImV4cCI6MjA3MDk2NzAwM30.6uAm_bDPN9aetYaKWA7zCvS8XDEVhmKKxA7RA7YK4JQ";
  const SLUG = "rainbowrules";
  let sb = null;

  // --- DOM
  const gridEl   = document.getElementById('grid');
  const levelEl  = document.getElementById('level');
  const bestEl   = document.getElementById('best');
  const globalEl = document.getElementById('global');
  const banner   = document.getElementById('banner');
  const restartBtn = document.getElementById('restart');
  const nextBtn    = document.getElementById('next');
  const toast    = document.getElementById('toast');

  // --- Device/local
  const DID_KEY  = "kapework_did_v1";
  const BEST_KEY = "rainbowrules_best_v1";
  let deviceId = localStorage.getItem(DID_KEY);
  if (!deviceId) { deviceId = (crypto?.randomUUID?.() || String(Math.random()).slice(2)); localStorage.setItem(DID_KEY, deviceId); }
  let bestLocal = parseInt(localStorage.getItem(BEST_KEY)||"0",10);
  bestEl.textContent = bestLocal;

  // --- Palette
  const COLORS = [
    {name:"RED",    css:"#ef4444"},
    {name:"ORANGE", css:"#f97316"},
    {name:"YELLOW", css:"#f59e0b"},
    {name:"GREEN",  css:"#22c55e"},
    {name:"BLUE",   css:"#3b82f6"},
    {name:"INDIGO", css:"#6366f1"},
    {name:"VIOLET", css:"#a855f7"}
  ];

  const COLS = 4; // grid columns remain 4; rows shrink as tiles are removed

  // --- Helpers
  function rand(a,b){ return Math.floor(Math.random()*(b-a+1))+a; }
  function choice(arr){ return arr[rand(0,arr.length-1)]; }

  // --- Dynamic board-aware predicates
  function makePredicates(state){
    const len = state.tiles.length;
    const lastRow = Math.floor((len-1)/COLS);
    const topRow = 0;

    return {
      isTop:     (i)=> Math.floor(i/COLS) === topRow,
      isBottom:  (i)=> Math.floor(i/COLS) === lastRow,
      isLeft:    (i)=> i % COLS === 0,
      isRight:   (i)=> i % COLS === (COLS-1),
      isCorner:  (i)=> {
        const tl = 0;
        const tr = Math.min(COLS-1, len-1);
        const bl = Math.max(0, len - ((len % COLS) || COLS));
        const br = len-1;
        return i===tl || i===tr || i===bl || i===br;
      }
    };
  }

  // --- Rule generators (use dynamic predicates every call)
  const RULES = {
    color: (c)=>({
      kind:"color", desc:`Tap ${c.name}`, nextTargets(state){
        return state.tiles.map((t,i)=> ({t,i})).filter(x=>x.t.alive && x.t.color===c.name).map(x=>x.i);
      }}),
    odd:   ()=>({ kind:"odd",   desc:"Tap ODD numbers", nextTargets(state){
      return state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive && x.t.num%2===1).map(x=>x.i);
    }}),
    even:  ()=>({ kind:"even",  desc:"Tap EVEN numbers", nextTargets(state){
      return state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive && x.t.num%2===0).map(x=>x.i);
    }}),
    top:   ()=>({ kind:"top",   desc:"Tap TOP row", nextTargets(state){
      const P = makePredicates(state);
      return state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive && P.isTop(x.i)).map(x=>x.i);
    }}),
    bottom:()=>({ kind:"bottom",desc:"Tap BOTTOM row", nextTargets(state){
      const P = makePredicates(state);
      return state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive && P.isBottom(x.i)).map(x=>x.i);
    }}),
    leftcol:()=>({ kind:"leftcol",desc:"Tap LEFT column", nextTargets(state){
      const P = makePredicates(state);
      return state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive && P.isLeft(x.i)).map(x=>x.i);
    }}),
    rightcol:()=>({ kind:"rightcol",desc:"Tap RIGHT column", nextTargets(state){
      const P = makePredicates(state);
      return state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive && P.isRight(x.i)).map(x=>x.i);
    }}),
    corners:()=>({ kind:"corners",desc:"Tap CORNERS", nextTargets(state){
      const P = makePredicates(state);
      return state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive && P.isCorner(x.i)).map(x=>x.i);
    }}),
    ascending:()=>({ kind:"ascending", desc:"Tap numbers ASCENDING", nextTargets(state){
      const alive = state.tiles.map((t,i)=>({t,i})).filter(x=>x.t.alive);
      if (!alive.length) return [];
      const min = alive.reduce((a,b)=> a.t.num<=b.t.num ? a : b );
      return [min.i];
    }})
  };

  // --- Game state
  const state = {
    level:1,
    rules:[],         // [{kind, desc, nextTargets(state)}]
    tiles:[],         // {el,num,color,alive}
    currentRuleIdx:0, // we apply rules from newest -> oldest
    presenting:false
  };

  function buildGrid(){
    gridEl.innerHTML = "";
    state.tiles = Array.from({length:16}, (_,i)=>{
      const c = choice(COLORS);
      const num = rand(1,9);
      const el = document.createElement('div');
      el.className = 'cell';
      el.style.background = c.css;
      el.textContent = num;
      el.dataset.idx = i;
      gridEl.appendChild(el);
      return { el, num, color:c.name, alive:true };
    });
    reindexTiles();
  }

  function reindexTiles(){
    state.tiles.forEach((t,idx)=>{ t.el.dataset.idx = idx; });
  }

  function addNewRule(){
    const candidates = [
      RULES.color(choice(COLORS)),
      RULES.odd(), RULES.even(),
      RULES.top(), RULES.bottom(), RULES.leftcol(), RULES.rightcol(),
      RULES.corners(),
      RULES.ascending()
    ];
    let r = choice(candidates);
    let tries = 0;
    while (r.nextTargets(state).length===0 && tries<10){ r = choice(candidates); tries++; }
    state.rules.push(r);
    flashBanner(`Rule ${state.rules.length}: ${r.desc}`);
  }

  function flashBanner(text){
    banner.textContent = text;
    banner.classList.add('show');
    state.presenting = true;
    setTimeout(()=>{ banner.textContent = ""; banner.classList.remove('show'); state.presenting=false; }, 1200);
  }

  function startLevel(resetAll=false){
    toast.textContent = "";
    if (resetAll){ state.rules=[]; state.level=1; }
    buildGrid();
    levelEl.textContent = state.level;
    // Ensure we have exactly 'level' rules, adding the new one now
    while (state.rules.length < state.level) addNewRule();
    // newest first
    state.currentRuleIdx = state.rules.length - 1;

    // brief hint for the newest rule
    const targets = state.rules[state.currentRuleIdx].nextTargets(state);
    state.tiles.forEach((t,i)=>{ if (!targets.includes(i)) t.el.classList.add('off'); });
    setTimeout(()=> state.tiles.forEach(t=>t.el.classList.remove('off')), 800);
  }

  function advanceBackwardThroughRules(){
    // move to the previous rule that still has targets
    state.currentRuleIdx--;
    while (state.currentRuleIdx >= 0 &&
           state.rules[state.currentRuleIdx].nextTargets(state).length===0){
      state.currentRuleIdx--;
    }
    if (state.currentRuleIdx < 0){
      // Level complete -> increase level, maybe update best, start next level
      toast.textContent = "Level up!";
      toast.className = "toast ok";
      state.level++;
      levelEl.textContent = state.level;
      updateBest();
      setTimeout(()=>{ startLevel(); }, 800);
    }else{
      flashBanner(`Rule ${state.currentRuleIdx+1}`);
    }
  }

  function removeTile(i){
    const t = state.tiles[i];
    t.alive = false;
    // Remove from DOM and array, then reindex
    t.el.remove();
    state.tiles.splice(i,1);
    reindexTiles();
  }

  function handleTap(i){
    if (state.presenting) return;
    // Guard index (in case user taps while a removal is happening)
    if (i<0 || i>=state.tiles.length) return;

    const r = state.rules[state.currentRuleIdx];
    const targets = r.nextTargets(state);

    // If no targets for this rule (because board shrank), step backward
    if (targets.length===0){ advanceBackwardThroughRules(); return; }

    const isAscending = (r.kind === "ascending");
    if (isAscending){
      const next = targets[0];
      if (i===next){ removeTile(i); afterRemovalCheck(r); }
      else fail();
      return;
    }

    // Set-based rules: any target is OK
    if (targets.includes(i)){
      removeTile(i);
      afterRemovalCheck(r);
    } else {
      fail();
    }

    function afterRemovalCheck(rule){
      // If this rule has no remaining matches on the shrunken board, go to the previous rule
      if (rule.nextTargets(state).length===0) advanceBackwardThroughRules();
    }
  }

  function fail(){
    toast.textContent = "Oops! Wrong tile.";
    toast.className = "toast err";
    state.level = 1;
    setTimeout(()=>{ startLevel(true); toast.textContent=""; toast.className="toast"; }, 700);
  }

  // Click / keyboard
  gridEl.addEventListener('click', (e)=>{
    const cell = e.target.closest('.cell'); if (!cell) return;
    handleTap(parseInt(cell.dataset.idx,10));
  });

  window.addEventListener('keydown', (e)=>{
    if (e.target && ['INPUT','TEXTAREA'].includes(e.target.tagName)) return;
    // Keyboard mapping: 1-4 top row, QWER next, ASDF next, ZXCV bottom (current layout)
    const map = {
      '1':0,'2':1,'3':2,'4':3,
      'q':4,'w':5,'e':6,'r':7,
      'a':8,'s':9,'d':10,'f':11,
      'z':12,'x':13,'c':14,'v':15
    };
    const k = e.key.toLowerCase();
    if (k in map){
      const idx = map[k];
      // idx may be out of range when the board shrinks
      if (idx < state.tiles.length) { e.preventDefault(); handleTap(idx); }
      return;
    }
    if (k==='enter'){ startLevel(); }
  });

  restartBtn.addEventListener('click', ()=> startLevel(true));
  nextBtn.addEventListener('click', ()=> startLevel());

  // --- Best / Global (same as before)
  function updateBest(){
    if (state.level-1 > bestLocal){
      bestLocal = state.level-1;
      localStorage.setItem(BEST_KEY, String(bestLocal));
      bestEl.textContent = bestLocal;
      upsertBest(bestLocal);
    }
  }
  async function upsertBest(val){
    try{
      if (!sb) sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
      await sb.from("scores").upsert(
        { slug: SLUG, device_id: deviceId, best_streak: val },
        { onConflict: "slug,device_id" }
      );
      refreshGlobal();
    }catch(e){}
  }
  async function refreshGlobal(){
    try{
      if (!sb) sb = window.supabase.createClient(SUPABASE_URL, SUPABASE_ANON);
      const { data } = await sb.from("global_best_scores").select().eq("slug", SLUG).maybeSingle();
      globalEl.textContent = data?.global_best ?? 0;
    }catch(e){}
  }

  // Boot
  refreshGlobal();
  startLevel(true);
})();
</script>
</body>
</html>