<!DOCTYPE html>

<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <meta name="color-scheme" content="dark">
    <meta name="theme-color" content="#0f172a">
    <title>Make 24 | Kapework</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Space+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

```
    :root {
        --cyan: #22d3ee;
        --cyan-dark: #0891b2;
        --cyan-glow: rgba(34, 211, 238, 0.3);
        --bg: #0f172a;
        --card-bg: #1e293b;
        --card-border: #334155;
        --text: #f1f5f9;
        --text-muted: #94a3b8;
        --success: #10b981;
        --error: #ef4444;
        --warning: #f59e0b;
        --gold: #fbbf24;
        color-scheme: dark;
    }

    html, body {
        height: 100%;
        overflow: hidden;
        background: #0f172a;
    }

    body {
        font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
        background: #0f172a;
        color: #f1f5f9;
        display: flex;
        flex-direction: column;
        align-items: center;
        min-height: 100dvh;
        padding: 16px;
        padding-bottom: env(safe-area-inset-bottom, 16px);
    }

    /* Header */
    .header {
        width: 100%;
        max-width: 400px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 8px 0;
        margin-bottom: 24px;
    }

    .puzzle-number {
        font-family: 'Space Mono', monospace;
        font-size: 1.5rem;
        font-weight: 700;
        color: #22d3ee;
        cursor: pointer;
        transition: opacity 0.2s;
    }

    .puzzle-number:hover {
        opacity: 0.8;
    }

    .header-right {
        display: flex;
        align-items: center;
        gap: 16px;
    }

    .undo-btn {
        font-size: 1.5rem;
        color: #94a3b8;
        background: none;
        border: none;
        cursor: pointer;
        opacity: 0;
        transition: opacity 0.2s, color 0.2s;
        padding: 4px;
        pointer-events: none;
    }

    .undo-btn.visible {
        opacity: 0.6;
        pointer-events: auto;
    }

    .undo-btn.visible:hover {
        opacity: 1;
        color: #22d3ee;
    }

    .undo-btn.visible:active {
        transform: scale(0.9);
    }

    .streak-display {
        display: flex;
        align-items: center;
        gap: 6px;
        font-size: 1.25rem;
        font-weight: 700;
    }

    .streak-display .fire {
        font-size: 1.5rem;
    }

    .freeze-indicator {
        font-size: 1rem;
        margin-left: 4px;
        opacity: 0.8;
    }

    /* Game Container - centered vertically, shifted up */
    .game-container {
        flex: 1;
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
        width: 100%;
        max-width: 400px;
        position: relative;
        margin-top: -80px; /* Shift up more to center visually */
    }

    /* Current Result Display - only shown when down to 1 card */
    .result-display {
        font-family: 'Space Mono', monospace;
        font-size: 3.5rem;
        font-weight: 700;
        color: #f1f5f9;
        height: 60px;
        display: flex;
        align-items: center;
        justify-content: center;
        transition: color 0.3s, transform 0.2s, opacity 0.3s;
        margin-bottom: 24px;
        opacity: 0;
    }

    .result-display.visible {
        opacity: 1;
    }

    .result-display.success {
        color: #10b981;
        transform: scale(1.1);
    }

    .result-display.error {
        color: #ef4444;
    }

    /* Diamond Grid Layout - WIDER spread, LARGER tiles */
    .diamond-grid {
        display: grid;
        grid-template-columns: 1fr 1fr 1fr;
        grid-template-rows: 1fr 1fr 1fr;
        gap: 12px;
        width: 320px;
        height: 320px;
        position: relative;
    }

    /* Grid slot positions */
    .slot {
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .slot.top {
        grid-column: 2;
        grid-row: 1;
    }

    .slot.left {
        grid-column: 1;
        grid-row: 2;
    }

    .slot.right {
        grid-column: 3;
        grid-row: 2;
    }

    .slot.bottom {
        grid-column: 2;
        grid-row: 3;
    }

    /* Cards - LARGER with bigger font */
    .card {
        width: 96px;
        height: 96px;
        background: #1e293b;
        border: 2px solid #334155;
        border-radius: 16px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-family: 'Space Mono', monospace;
        font-size: 2.75rem;
        font-weight: 700;
        color: #f1f5f9;
        cursor: pointer;
        transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
        -webkit-user-select: none;
        user-select: none;
    }

    .card:active {
        transform: scale(0.95);
    }

    .card.selected {
        border-color: #22d3ee;
        box-shadow: 0 0 24px rgba(34, 211, 238, 0.3);
        transform: scale(1.08);
    }

    .card.selected.first {
        border-color: #22d3ee;
    }

    .card.selected.second {
        border-color: #f59e0b;
        box-shadow: 0 0 24px rgba(245, 158, 11, 0.3);
    }

    .card.used {
        opacity: 0;
        pointer-events: none;
        transform: scale(0.8);
    }

    /* Centered Operators Overlay - semi-transparent to see tiles */
    .operators-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(15, 23, 42, 0.4);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 50;
    }

    .operators-overlay.show {
        display: flex;
    }

    .operators-grid {
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        gap: 12px;
        padding: 14px;
        background: rgba(30, 41, 59, 0.85);
        border-radius: 20px;
        border: 1px solid rgba(51, 65, 85, 0.6);
    }

    .op-btn {
        width: 54px;
        height: 54px;
        border-radius: 50%;
        border: 2px solid #22d3ee;
        background: rgba(30, 41, 59, 0.95);
        color: #f1f5f9;
        font-size: 1.5rem;
        font-weight: 700;
        cursor: pointer;
        transition: all 0.15s ease;
        display: flex;
        align-items: center;
        justify-content: center;
    }

    .op-btn:hover {
        background: rgba(34, 211, 238, 0.2);
        transform: scale(1.1);
    }

    .op-btn:active {
        transform: scale(0.95);
    }

    /* Move dots - shows progress, green for moves, muted for excess */
    .move-dots {
        position: fixed;
        bottom: 40px;
        left: 50%;
        transform: translateX(-50%);
        display: flex;
        gap: 6px;
        justify-content: center;
        align-items: center;
    }

    .move-dot {
        width: 8px;
        height: 8px;
        border-radius: 50%;
        background: #334155;
        transition: background 0.3s, transform 0.2s;
    }

    .move-dot.filled {
        background: #10b981;
        transform: scale(1.1);
    }

    .move-dot.excess {
        background: #64748b;
    }

    .move-dot.perfect-hint {
        background: #334155;
        opacity: 0.5;
    }

    /* Message overlay */
    .message {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #1e293b;
        border: 2px solid #22d3ee;
        border-radius: 16px;
        padding: 32px;
        text-align: center;
        z-index: 100;
        max-width: 90%;
        width: 320px;
        box-shadow: 0 0 40px rgba(34, 211, 238, 0.3);
        display: none;
    }

    .message.show {
        display: block;
        animation: popIn 0.3s ease;
    }

    @keyframes popIn {
        from {
            opacity: 0;
            transform: translate(-50%, -50%) scale(0.8);
        }
        to {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
        }
    }

    .message h2 {
        font-size: 1.5rem;
        margin-bottom: 8px;
        color: #f1f5f9;
    }

    .message h2.perfect {
        color: #fbbf24;
    }

    .message p {
        color: #94a3b8;
        margin-bottom: 16px;
    }

    .message .stats {
        font-family: 'Space Mono', monospace;
        font-size: 1.25rem;
        margin: 16px 0;
        color: #f1f5f9;
    }

    .message .btn {
        margin-top: 8px;
    }

    .btn {
        padding: 12px 24px;
        border-radius: 8px;
        border: none;
        font-family: 'DM Sans', sans-serif;
        font-size: 1rem;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s ease;
    }

    .btn-primary {
        background: #22d3ee;
        color: #0f172a;
    }

    .btn-primary:hover {
        background: #0891b2;
    }

    .btn-secondary {
        background: #1e293b;
        color: #f1f5f9;
        border: 1px solid #334155;
        margin-left: 8px;
    }

    /* Archive Modal */
    .modal-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.85);
        display: none;
        align-items: center;
        justify-content: center;
        z-index: 200;
        padding: 16px;
    }

    .modal-overlay.show {
        display: flex;
    }

    .modal {
        background: #1e293b;
        border-radius: 16px;
        padding: 24px;
        max-width: 360px;
        width: 100%;
        max-height: 80vh;
        overflow-y: auto;
    }

    .modal h2 {
        text-align: center;
        margin-bottom: 16px;
        color: #22d3ee;
    }

    .archive-list {
        display: grid;
        grid-template-columns: repeat(5, 1fr);
        gap: 8px;
    }

    .archive-item {
        aspect-ratio: 1;
        display: flex;
        align-items: center;
        justify-content: center;
        background: #0f172a;
        border: 1px solid #334155;
        border-radius: 8px;
        font-family: 'Space Mono', monospace;
        font-size: 0.875rem;
        color: #f1f5f9;
        cursor: pointer;
        transition: all 0.15s;
    }

    .archive-item:hover {
        border-color: #22d3ee;
    }

    .archive-item.completed {
        background: rgba(16, 185, 129, 0.2);
        border-color: #10b981;
    }

    .archive-item.perfect {
        background: rgba(251, 191, 36, 0.2);
        border-color: #fbbf24;
        position: relative;
    }

    .archive-item.perfect::after {
        content: '‚≠ê';
        position: absolute;
        top: -4px;
        right: -4px;
        font-size: 0.6rem;
    }

    .archive-item.today {
        border-color: #22d3ee;
        box-shadow: 0 0 10px rgba(34, 211, 238, 0.3);
    }

    .modal-close {
        display: block;
        width: 100%;
        margin-top: 16px;
        padding: 12px;
        background: #0f172a;
        border: 1px solid #334155;
        border-radius: 8px;
        color: #f1f5f9;
        font-size: 1rem;
        cursor: pointer;
    }

    /* Confetti */
    .confetti-container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        pointer-events: none;
        z-index: 1000;
        overflow: hidden;
    }

    .confetti {
        position: absolute;
        width: 10px;
        height: 10px;
        opacity: 0;
    }

    @keyframes confetti-fall {
        0% {
            transform: translateY(-100px) rotate(0deg);
            opacity: 1;
        }
        100% {
            transform: translateY(100vh) rotate(720deg);
            opacity: 0;
        }
    }

    /* Archive mode indicator */
    .archive-banner {
        background: #f59e0b;
        color: #0f172a;
        padding: 8px 16px;
        border-radius: 8px;
        font-size: 0.875rem;
        font-weight: 600;
        position: fixed;
        top: 60px;
        left: 50%;
        transform: translateX(-50%);
        display: none;
        z-index: 10;
    }

    .archive-banner.show {
        display: block;
    }

</style>
```

</head>
<body>
    <div class="header">
        <div class="puzzle-number" id="puzzleNumber" title="Tap for archive">#‚Äî</div>
        <div class="header-right">
            <button class="undo-btn" id="undoBtn" title="Undo">‚Ü∂</button>
            <div class="streak-display">
                <span class="fire">üî•</span>
                <span id="streakCount">0</span>
                <span class="freeze-indicator" id="freezeIndicator"></span>
            </div>
        </div>
    </div>

```
<div class="archive-banner" id="archiveBanner">
    üìÖ History Mode
</div>

<div class="game-container">
    <div class="result-display" id="resultDisplay">‚Äî</div>

    <div class="diamond-grid" id="diamondGrid">
        <div class="slot top" id="slot0"></div>
        <div class="slot left" id="slot1"></div>
        <div class="slot right" id="slot2"></div>
        <div class="slot bottom" id="slot3"></div>
    </div>
</div>

<!-- Operators appear centered when 2 cards selected -->
<div class="operators-overlay" id="operatorsOverlay">
    <div class="operators-grid">
        <button class="op-btn" data-op="+">+</button>
        <button class="op-btn" data-op="-">‚àí</button>
        <button class="op-btn" data-op="*">√ó</button>
        <button class="op-btn" data-op="/">√∑</button>
    </div>
</div>

<div class="move-dots" id="moveDots">
    <div class="move-dot perfect-hint"></div>
    <div class="move-dot perfect-hint"></div>
    <div class="move-dot perfect-hint"></div>
</div>


<div class="message" id="successMessage">
    <h2 id="successTitle">üéâ Nice!</h2>
    <p id="successSubtitle">You made 24!</p>
    <div class="stats" id="successStats"></div>
    <button class="btn btn-primary" id="shareBtn">Share</button>
    <button class="btn btn-secondary" id="closeSuccessBtn">Close</button>
</div>

<div class="modal-overlay" id="archiveModal">
    <div class="modal">
        <h2>üìÖ History</h2>
        <div class="archive-list" id="archiveList"></div>
        <button class="modal-close" id="closeArchive">Close</button>
    </div>
</div>

<div class="confetti-container" id="confetti"></div>

<script>
    // Supabase config
    const SUPABASE_URL = 'https://fimsbfcvavpehryvvcho.supabase.co';
    const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpbXNiZmN2YXZwZWhyeXZ2Y2hvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzOTEwMDMsImV4cCI6MjA3MDk2NzAwM30.6uAm_bDPN9aetYaKWA7zCvS8XDEVhmKKxA7RA7YK4JQ';

    // Constants
    const STORAGE_KEY = 'make24_v5';
    const ARCHIVE_DAYS = 30;
    const STREAK_FREEZE_INTERVAL = 7;
    const PERFECT_MOVES = 3;

    // Game state (persisted per device)
    let gameState = {
        deviceId: null,
        streak: 0,
        freezes: 0,
        lastPlayedDate: null,
        history: {}, // { puzzleNum: { completed: bool, moves: num } }
    };

    let currentPuzzle = {
        numbers: [],
        puzzleNum: 0,
        date: null,
        isArchive: false
    };

    let playState = {
        cards: [], // { value, used, slot }
        selected: [], // indices
        moves: 0, // counts ALL moves including undos
        cardStates: [], // for undo - stores previous card states
        operatorHistory: [], // tracks operators used (for perfect share)
        undoCount: 0, // tracks number of undos
        startTime: null, // when puzzle started
        endTime: null, // when puzzle solved
        completed: false
    };

    // Seeded RNG (Mulberry32)
    function mulberry32(seed) {
        return function() {
            let t = seed += 0x6D2B79F5;
            t = Math.imul(t ^ t >>> 15, t | 1);
            t ^= t + Math.imul(t ^ t >>> 7, t | 61);
            return ((t ^ t >>> 14) >>> 0) / 4294967296;
        };
    }

    // Get puzzle number from date
    function getPuzzleNumber(date) {
        const epoch = new Date('2025-01-01T00:00:00Z');
        const diff = date - epoch;
        return Math.floor(diff / (24 * 60 * 60 * 1000)) + 1;
    }

    // Get date from puzzle number
    function getDateFromPuzzleNumber(num) {
        const epoch = new Date('2025-01-01T00:00:00Z');
        return new Date(epoch.getTime() + (num - 1) * 24 * 60 * 60 * 1000);
    }

    // Get today's puzzle number (UTC)
    function getTodayPuzzleNumber() {
        const now = new Date();
        const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
        return getPuzzleNumber(utcDate);
    }

    // Generate 4 numbers for a puzzle
    function generatePuzzle(puzzleNum) {
        const rng = mulberry32(puzzleNum * 12345);
        const numbers = [];
        for (let i = 0; i < 4; i++) {
            numbers.push(Math.floor(rng() * 9) + 1); // 1-9
        }
        return numbers;
    }

    // Device ID
    function getDeviceId() {
        let id = localStorage.getItem('make24_device_id');
        if (!id) {
            id = 'dev_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
            localStorage.setItem('make24_device_id', id);
        }
        return id;
    }

    // Load/save state
    function loadState() {
        try {
            const saved = localStorage.getItem(STORAGE_KEY);
            if (saved) {
                gameState = { ...gameState, ...JSON.parse(saved) };
            }
        } catch (e) {
            console.error('Failed to load state:', e);
        }
        gameState.deviceId = getDeviceId();
    }

    function saveState() {
        try {
            localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState));
        } catch (e) {
            console.error('Failed to save state:', e);
        }
    }

    // Streak management
    function updateStreak() {
        const today = getTodayPuzzleNumber();
        const yesterday = today - 1;
        
        if (gameState.lastPlayedDate === today) {
            // Already played today
            return;
        }
        
        if (gameState.lastPlayedDate === yesterday) {
            // Consecutive day - streak continues
        } else if (gameState.lastPlayedDate === yesterday - 1 && gameState.freezes > 0) {
            // Missed one day but have freeze
            gameState.freezes--;
            saveState();
        } else if (gameState.lastPlayedDate && gameState.lastPlayedDate < yesterday) {
            // Streak broken
            gameState.streak = 0;
            saveState();
        }
        
        updateStreakDisplay();
    }

    function incrementStreak() {
        gameState.streak++;
        gameState.lastPlayedDate = currentPuzzle.puzzleNum;
        
        // Award freeze every 7 days
        if (gameState.streak > 0 && gameState.streak % STREAK_FREEZE_INTERVAL === 0) {
            gameState.freezes++;
        }
        
        saveState();
        updateStreakDisplay();
    }

    function updateStreakDisplay() {
        document.getElementById('streakCount').textContent = gameState.streak;
        const freezeEl = document.getElementById('freezeIndicator');
        freezeEl.textContent = gameState.freezes > 0 ? '‚ùÑÔ∏è'.repeat(Math.min(gameState.freezes, 3)) : '';
    }

    // Initialize puzzle
    function initPuzzle(puzzleNum, isArchive = false) {
        // Close any open messages first
        document.getElementById('successMessage').classList.remove('show');
        hideOperators();
        
        currentPuzzle.puzzleNum = puzzleNum;
        currentPuzzle.numbers = generatePuzzle(puzzleNum);
        currentPuzzle.isArchive = isArchive;
        currentPuzzle.date = getDateFromPuzzleNumber(puzzleNum);
        
        // Reset play state
        playState.moves = 0;
        playState.completed = false;
        
        // Check history - if already solved, mark completed
        const history = gameState.history[puzzleNum];
        if (history?.completed) {
            playState.completed = true;
            playState.moves = history.moves || 0;
        }
        
        resetPlay();
        updateUI();
    }

    function resetPlay() {
        playState.cards = currentPuzzle.numbers.map((v, i) => ({
            value: v,
            used: false,
            slot: i
        }));
        playState.selected = [];
        playState.cardStates = [];
        playState.operatorHistory = [];
        playState.undoCount = 0;
        playState.startTime = null;
        playState.endTime = null;
        
        renderCards();
        hideOperators();
        updateResult();
    }

    // Render cards into grid slots
    function renderCards() {
        const slots = ['slot0', 'slot1', 'slot2', 'slot3'];
        
        slots.forEach((slotId, i) => {
            const slot = document.getElementById(slotId);
            slot.innerHTML = '';
            
            const cardData = playState.cards.find(c => c.slot === i && !c.used);
            if (cardData) {
                const card = document.createElement('div');
                card.className = 'card';
                card.textContent = formatNumber(cardData.value);
                card.dataset.index = playState.cards.indexOf(cardData);
                
                const cardIndex = playState.cards.indexOf(cardData);
                if (playState.selected.includes(cardIndex)) {
                    card.classList.add('selected');
                    if (playState.selected[0] === cardIndex) {
                        card.classList.add('first');
                    } else {
                        card.classList.add('second');
                    }
                }
                
                card.addEventListener('click', () => selectCard(cardIndex));
                slot.appendChild(card);
            }
        });
    }

    function formatNumber(n) {
        if (Number.isInteger(n)) return n.toString();
        // Show fractions nicely
        const rounded = Math.round(n * 100) / 100;
        if (Number.isInteger(rounded)) return rounded.toString();
        return rounded.toFixed(2).replace(/\.?0+$/, '');
    }

    function selectCard(index) {
        if (playState.completed) return;
        if (playState.cards[index].used) return;
        
        const pos = playState.selected.indexOf(index);
        if (pos !== -1) {
            // Deselect
            playState.selected.splice(pos, 1);
            hideOperators();
        } else if (playState.selected.length < 2) {
            playState.selected.push(index);
            if (playState.selected.length === 2) {
                showOperators();
            }
        }
        
        renderCards();
        
        // Request motion permission on first interaction (iOS requires user gesture)
        // Do this after selection logic so it doesn't interfere
        maybeRequestMotion();
    }

    function showOperators() {
        document.getElementById('operatorsOverlay').classList.add('show');
    }

    function hideOperators() {
        document.getElementById('operatorsOverlay').classList.remove('show');
    }

    function applyOperation(op) {
        if (playState.selected.length !== 2 || playState.completed) return;
        
        const [i, j] = playState.selected;
        const a = playState.cards[i].value;
        const b = playState.cards[j].value;
        
        let result;
        switch (op) {
            case '+': result = a + b; break;
            case '-': result = a - b; break;
            case '*': result = a * b; break;
            case '/': 
                if (b === 0) return;
                result = a / b;
                break;
        }
        
        // Start timer on first move
        if (!playState.startTime) {
            playState.startTime = Date.now();
        }
        
        // Save state for undo (deep copy)
        playState.cardStates.push({
            cards: JSON.parse(JSON.stringify(playState.cards)),
            operators: [...playState.operatorHistory]
        });
        
        // Track the operator used
        playState.operatorHistory.push(op);
        
        // Mark cards as used
        playState.cards[i].used = true;
        playState.cards[j].used = true;
        
        // Find empty slot (prefer first card's slot)
        const emptySlot = playState.cards[i].slot;
        
        // Create new card
        playState.cards.push({
            value: result,
            used: false,
            slot: emptySlot
        });
        
        playState.selected = [];
        playState.moves++; // Count as a move
        
        hideOperators();
        renderCards();
        updateResult();
        updateMoveDots();
        
        // Check for win/lose
        checkGameState();
    }

    function undo() {
        if (playState.cardStates.length === 0 || playState.completed) return;
        
        // Restore previous state
        const prevState = playState.cardStates.pop();
        playState.cards = prevState.cards;
        playState.operatorHistory = prevState.operators;
        playState.selected = [];
        playState.moves++; // Undo counts as a move!
        playState.undoCount++; // Track undos separately for share
        
        hideOperators();
        renderCards();
        updateResult();
        updateMoveDots();
    }

    function updateResult() {
        const remaining = playState.cards.filter(c => !c.used);
        const display = document.getElementById('resultDisplay');
        
        if (remaining.length === 1) {
            const val = remaining[0].value;
            display.textContent = formatNumber(val);
            display.classList.add('visible');
            if (Math.abs(val - 24) < 0.0001) {
                display.classList.add('success');
                display.classList.remove('error');
            } else {
                display.classList.remove('success');
                display.classList.add('error');
            }
        } else {
            display.textContent = '';
            display.classList.remove('visible', 'success', 'error');
        }
        
        // Update undo button visibility
        updateUndoButton();
    }
    
    function updateUndoButton() {
        const undoBtn = document.getElementById('undoBtn');
        if (playState.cardStates.length > 0 && !playState.completed) {
            undoBtn.classList.add('visible');
        } else {
            undoBtn.classList.remove('visible');
        }
    }

    function checkGameState() {
        const remaining = playState.cards.filter(c => !c.used);
        
        if (remaining.length === 1) {
            const val = remaining[0].value;
            
            if (Math.abs(val - 24) < 0.0001) {
                handleWin();
            } else {
                handleWrongAnswer();
            }
        }
    }

    function handleWin() {
        playState.completed = true;
        playState.endTime = Date.now();
        
        // Calculate solve time in seconds
        const solveTime = playState.startTime ? 
            Math.round((playState.endTime - playState.startTime) / 1000) : 0;
        
        // Update history
        gameState.history[currentPuzzle.puzzleNum] = {
            completed: true,
            moves: playState.moves,
            operators: [...playState.operatorHistory],
            undos: playState.undoCount,
            solveTime: solveTime
        };
        
        // Update streak only for today's puzzle
        if (!currentPuzzle.isArchive) {
            incrementStreak();
        }
        
        saveState();
        trackPlay(true);
        
        updateMoveDots();
        showConfetti();
        
        // Check for perfect game
        const isPerfect = playState.moves === PERFECT_MOVES;
        const title = document.getElementById('successTitle');
        const subtitle = document.getElementById('successSubtitle');
        
        if (isPerfect) {
            title.textContent = '‚≠ê Perfect!';
            title.classList.add('perfect');
            subtitle.textContent = 'Solved in just 3 moves!';
        } else {
            title.textContent = 'üéâ Nice!';
            title.classList.remove('perfect');
            subtitle.textContent = 'You made 24!';
        }
        
        const stats = document.getElementById('successStats');
        stats.innerHTML = `Moves: ${playState.moves}`;
        
        setTimeout(() => {
            document.getElementById('successMessage').classList.add('show');
        }, 500);
    }

    function handleWrongAnswer() {
        // Just reset the cards and let player try again
        // Moves already counted, so player sees their progress
        setTimeout(() => {
            playState.cards = currentPuzzle.numbers.map((v, i) => ({
                value: v,
                used: false,
                slot: i
            }));
            playState.selected = [];
            playState.cardStates = [];
            renderCards();
            updateResult();
        }, 800);
    }

    function updateMoveDots() {
        const container = document.getElementById('moveDots');
        container.innerHTML = '';
        
        // Always show at least 3 dots (perfect target)
        const totalDots = Math.max(3, playState.moves);
        
        for (let i = 0; i < totalDots; i++) {
            const dot = document.createElement('div');
            dot.className = 'move-dot';
            
            if (i < playState.moves) {
                // Filled dots for moves made
                if (i < 3) {
                    dot.classList.add('filled'); // Green for first 3
                } else {
                    dot.classList.add('excess'); // Muted for excess
                }
            } else {
                // Unfilled dots showing perfect target
                dot.classList.add('perfect-hint');
            }
            
            container.appendChild(dot);
        }
    }

    function updateUI() {
        document.getElementById('puzzleNumber').textContent = `#${currentPuzzle.puzzleNum}`;
        document.getElementById('archiveBanner').classList.toggle('show', currentPuzzle.isArchive);
        updateStreakDisplay();
        updateMoveDots();
    }

    // Confetti
    function showConfetti() {
        const container = document.getElementById('confetti');
        const colors = ['#22d3ee', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#fbbf24'];
        
        for (let i = 0; i < 60; i++) {
            const confetti = document.createElement('div');
            confetti.className = 'confetti';
            confetti.style.left = Math.random() * 100 + '%';
            confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
            confetti.style.animation = `confetti-fall ${1.5 + Math.random()}s ease-out forwards`;
            confetti.style.animationDelay = Math.random() * 0.5 + 's';
            confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
            confetti.style.width = (6 + Math.random() * 8) + 'px';
            confetti.style.height = (6 + Math.random() * 8) + 'px';
            container.appendChild(confetti);
        }
        
        setTimeout(() => {
            container.innerHTML = '';
        }, 3000);
    }

    // Share Image Generator
    function generateShareImage() {
        return new Promise((resolve) => {
            const history = gameState.history[currentPuzzle.puzzleNum];
            const isPerfect = history?.completed && history.moves === PERFECT_MOVES && history.undos === 0;
            const isFast = history?.solveTime && history.solveTime <= 60;
            const operators = history?.operators || playState.operatorHistory;
            const undos = history?.undos || playState.undoCount;
            
            // Determine color scheme
            // Green = perfect & fast (<60s), Yellow = perfect but slow, Grey = not perfect
            let circleColor;
            if (isPerfect && isFast) {
                circleColor = '#22c55e'; // Green
            } else if (isPerfect) {
                circleColor = '#eab308'; // Yellow
            } else {
                circleColor = '#6b7280'; // Grey
            }
            
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // Canvas size
            const width = 600;
            const height = 200;
            canvas.width = width;
            canvas.height = height;
            
            // Background
            ctx.fillStyle = '#0f172a';
            ctx.fillRect(0, 0, width, height);
            
            // Calculate layout
            const logoSize = 56;
            const circleSize = 44;
            const circleGap = 12;
            const startX = 30;
            let currentX = startX;
            const centerY = height / 2;
            
            // Draw "24" logo (gold rounded square)
            ctx.fillStyle = '#ca8a04';
            roundRect(ctx, currentX, centerY - logoSize/2, logoSize, logoSize, 10);
            ctx.fill();
            
            // "24" text
            ctx.fillStyle = '#0f172a';
            ctx.font = 'bold 32px "Space Mono", monospace';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('24', currentX + logoSize/2, centerY + 2);
            
            currentX += logoSize + 20;
            
            // Draw puzzle number
            ctx.fillStyle = '#22d3ee';
            ctx.font = 'bold 36px "Space Mono", monospace';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            const puzzleText = `#${currentPuzzle.puzzleNum}`;
            ctx.fillText(puzzleText, currentX, centerY);
            currentX += ctx.measureText(puzzleText).width + 24;
            
            // Draw operator circles
            const opSymbols = {
                '+': '+',
                '-': '‚àí',
                '*': '√ó',
                '/': '√∑'
            };
            
            operators.forEach((op, i) => {
                // Circle
                ctx.beginPath();
                ctx.arc(currentX + circleSize/2, centerY, circleSize/2, 0, Math.PI * 2);
                ctx.fillStyle = circleColor;
                ctx.fill();
                
                // Operator symbol
                ctx.fillStyle = '#ffffff';
                ctx.font = 'bold 24px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(opSymbols[op] || op, currentX + circleSize/2, centerY);
                
                currentX += circleSize + circleGap;
            });
            
            // Draw undo circles (empty grey)
            for (let i = 0; i < undos; i++) {
                ctx.beginPath();
                ctx.arc(currentX + circleSize/2, centerY, circleSize/2, 0, Math.PI * 2);
                ctx.strokeStyle = '#6b7280';
                ctx.lineWidth = 3;
                ctx.stroke();
                
                // Undo symbol (‚Ü∂)
                ctx.fillStyle = '#6b7280';
                ctx.font = '20px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText('‚Ü∂', currentX + circleSize/2, centerY);
                
                currentX += circleSize + circleGap;
            }
            
            currentX += 12;
            
            // Draw URL pill
            const urlText = `make24.app/${currentPuzzle.puzzleNum}`;
            ctx.font = '18px "DM Sans", sans-serif';
            const urlWidth = ctx.measureText(urlText).width + 24;
            const pillHeight = 36;
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.15)';
            roundRect(ctx, currentX, centerY - pillHeight/2, urlWidth, pillHeight, pillHeight/2);
            ctx.fill();
            
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.textAlign = 'left';
            ctx.textBaseline = 'middle';
            ctx.fillText(urlText, currentX + 12, centerY);
            
            // Convert to blob
            canvas.toBlob((blob) => {
                resolve(blob);
            }, 'image/png');
        });
    }
    
    // Helper function for rounded rectangles
    function roundRect(ctx, x, y, width, height, radius) {
        ctx.beginPath();
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
        ctx.closePath();
    }
    
    // Generate text fallback for platforms that don't support image sharing
    function generateShareText() {
        const history = gameState.history[currentPuzzle.puzzleNum];
        const isPerfect = history?.completed && history.moves === PERFECT_MOVES && history.undos === 0;
        const operators = history?.operators || playState.operatorHistory;
        
        const opEmojis = { '+': '‚ûï', '-': '‚ûñ', '*': '‚úñÔ∏è', '/': '‚ûó' };
        const opText = operators.map(op => opEmojis[op]).join(' ');
        
        let text = `24 #${currentPuzzle.puzzleNum}\n`;
        text += isPerfect ? `üü¢ ${opText} üü¢\n` : `${opText}\n`;
        text += `üî• ${gameState.streak}\n`;
        text += `make24.app/${currentPuzzle.puzzleNum}`;
        
        return text;
    }

    async function share() {
        try {
            const imageBlob = await generateShareImage();
            const file = new File([imageBlob], `make24_${currentPuzzle.puzzleNum}.png`, { type: 'image/png' });
            
            // Try to share image if supported
            if (navigator.canShare && navigator.canShare({ files: [file] })) {
                await navigator.share({
                    files: [file],
                    title: `24 #${currentPuzzle.puzzleNum}`,
                });
            } else if (navigator.share) {
                // Fall back to text sharing
                await navigator.share({ text: generateShareText() });
            } else {
                // Fall back to clipboard
                copyToClipboard(generateShareText());
            }
        } catch (e) {
            if (e.name !== 'AbortError') {
                // User didn't cancel, try text fallback
                copyToClipboard(generateShareText());
            }
        }
    }

    function copyToClipboard(text) {
        navigator.clipboard.writeText(text).then(() => {
            alert('Copied to clipboard!');
        }).catch(() => {
            alert(text);
        });
    }

    // Archive
    // History
    function showArchive() {
        const modal = document.getElementById('archiveModal');
        const list = document.getElementById('archiveList');
        list.innerHTML = '';
        
        const today = getTodayPuzzleNumber();
        
        for (let i = 0; i < ARCHIVE_DAYS; i++) {
            const num = today - i;
            if (num < 1) continue;
            
            const item = document.createElement('div');
            item.className = 'archive-item';
            item.textContent = num;
            
            const history = gameState.history[num];
            if (history?.completed) {
                // Check if perfect (3 moves)
                if (history.moves === PERFECT_MOVES) {
                    item.classList.add('perfect');
                } else {
                    item.classList.add('completed');
                }
            }
            
            if (num === today) {
                item.classList.add('today');
            }
            
            item.addEventListener('click', () => {
                modal.classList.remove('show');
                initPuzzle(num, num !== today);
            });
            
            list.appendChild(item);
        }
        
        modal.classList.add('show');
    }

    // Track play to Supabase
    async function trackPlay(success) {
        try {
            const payload = {
                slug: `make24-${currentPuzzle.puzzleNum}`,
                device_id: gameState.deviceId,
                metadata: {
                    success: success,
                    moves: playState.moves,
                    numbers: currentPuzzle.numbers,
                    isArchive: currentPuzzle.isArchive,
                    streak: gameState.streak,
                    perfect: success && playState.moves === PERFECT_MOVES
                }
            };
            
            console.log('Tracking play to Supabase:', payload);
            
            const response = await fetch(`${SUPABASE_URL}/rest/v1/plays`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'apikey': SUPABASE_KEY,
                    'Authorization': `Bearer ${SUPABASE_KEY}`,
                    'Prefer': 'return=representation'
                },
                body: JSON.stringify(payload)
            });
            
            if (!response.ok) {
                const errorText = await response.text();
                console.error('Supabase error:', response.status, errorText);
            } else {
                const result = await response.json();
                console.log('Supabase success:', result);
            }
        } catch (e) {
            console.error('Failed to track play:', e);
        }
    }

    // Shake to undo (using DeviceMotion API)
    let lastShakeTime = 0;
    let shakeEnabled = false;
    const SHAKE_THRESHOLD = 25; // Higher threshold for more deliberate shakes
    const SHAKE_TIMEOUT = 800;
    let lastX = 0, lastY = 0, lastZ = 0;

    function handleMotion(event) {
        if (!shakeEnabled || playState.completed) return;
        
        const acc = event.accelerationIncludingGravity;
        if (!acc || acc.x === null) return;
        
        const x = acc.x;
        const y = acc.y;
        const z = acc.z;
        
        // Calculate change in acceleration
        const deltaX = Math.abs(x - lastX);
        const deltaY = Math.abs(y - lastY);
        const deltaZ = Math.abs(z - lastZ);
        
        lastX = x;
        lastY = y;
        lastZ = z;
        
        const totalDelta = deltaX + deltaY + deltaZ;
        const now = Date.now();
        
        if (totalDelta > SHAKE_THRESHOLD && now - lastShakeTime > SHAKE_TIMEOUT) {
            lastShakeTime = now;
            console.log('Shake detected! Delta:', totalDelta);
            undo();
        }
    }

    async function requestMotionPermission() {
        if (shakeEnabled) return true;
        
        try {
            if (typeof DeviceMotionEvent !== 'undefined' && 
                typeof DeviceMotionEvent.requestPermission === 'function') {
                // iOS 13+ requires permission
                const response = await DeviceMotionEvent.requestPermission();
                if (response === 'granted') {
                    window.addEventListener('devicemotion', handleMotion);
                    shakeEnabled = true;
                    console.log('Motion permission granted');
                    return true;
                } else {
                    console.log('Motion permission denied');
                    return false;
                }
            } else if ('DeviceMotionEvent' in window) {
                // Non-iOS or older iOS - no permission needed
                window.addEventListener('devicemotion', handleMotion);
                shakeEnabled = true;
                console.log('Motion events enabled (no permission needed)');
                return true;
            }
        } catch (e) {
            console.error('Motion permission error:', e);
        }
        return false;
    }

    // Request motion permission on first card click (user gesture required for iOS)
    let motionPermissionRequested = false;
    function maybeRequestMotion() {
        if (!motionPermissionRequested && 'DeviceMotionEvent' in window) {
            motionPermissionRequested = true;
            requestMotionPermission();
        }
    }

    // Event listeners
    document.querySelectorAll('.op-btn').forEach(btn => {
        btn.addEventListener('click', () => applyOperation(btn.dataset.op));
    });

    document.getElementById('undoBtn').addEventListener('click', undo);

    // Close operators overlay when clicking outside
    document.getElementById('operatorsOverlay').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
            playState.selected = [];
            hideOperators();
            renderCards();
        }
    });

    document.getElementById('puzzleNumber').addEventListener('click', showArchive);
    document.getElementById('closeArchive').addEventListener('click', () => {
        document.getElementById('archiveModal').classList.remove('show');
    });
    
    document.getElementById('shareBtn').addEventListener('click', share);
    
    document.getElementById('closeSuccessBtn').addEventListener('click', () => {
        document.getElementById('successMessage').classList.remove('show');
    });

    // Close modals on overlay click
    document.getElementById('archiveModal').addEventListener('click', (e) => {
        if (e.target === e.currentTarget) {
            e.currentTarget.classList.remove('show');
        }
    });

    // Initialize
    loadState();
    updateStreak();
    initPuzzle(getTodayPuzzleNumber(), false);
    
    // For non-iOS devices, try to enable motion right away
    if (!('ontouchstart' in window)) {
        // Desktop - likely no motion support, but try anyway
        if ('DeviceMotionEvent' in window && typeof DeviceMotionEvent.requestPermission !== 'function') {
            window.addEventListener('devicemotion', handleMotion);
            shakeEnabled = true;
        }
    }
</script>
```

</body>
</html>