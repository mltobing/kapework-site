<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Make 24 — Daily</title>
<style>
  :root { --bg:#0b1220; --panel:#121a2c; --ink:#e8eefc; --muted:#93a3c9; --bd:rgba(255,255,255,.08);
          --accent:#7dd3fc; --ok:#34d399; --err:#fb7185; }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{margin:0;background:var(--bg);color:var(--ink);font:16px/1.45 system-ui,-apple-system,Segoe UI,Roboto}

  .wrap{max-width:560px;margin:0 auto;padding:16px 16px 28px}
  header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
  h1{margin:0;font-size:20px}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border:1px solid var(--bd);border-radius:999px;background:#0e1729}
  .muted{color:var(--muted)}

  .panel{position:relative;background:var(--panel);border:1px solid var(--bd);border-radius:16px;padding:14px;overflow:hidden}
  /* big X lines */
  .panel::before,.panel::after{
    content:""; position:absolute; inset:16px; border-top:1px solid var(--bd); transform-origin:center; pointer-events:none; opacity:.7;
  }
  .panel::before{ transform:rotate(45deg) }
  .panel::after{ transform:rotate(-45deg) }

  /* diamond grid: 3x3, use center cross cells */
  .diamond{display:grid;grid-template-columns:1fr 1fr 1fr;grid-template-rows:1fr 1fr 1fr;gap:10px; height:360px; margin:4px 0 10px}
  .slot{display:flex;align-items:center;justify-content:center}
  .top    { grid-column:2; grid-row:1 }
  .left   { grid-column:1; grid-row:2 }
  .right  { grid-column:3; grid-row:2 }
  .bottom { grid-column:2; grid-row:3 }

  .card{width:120px;height:90px;border-radius:14px;border:1px solid var(--bd);
        background:rgba(255,255,255,.02);display:flex;align-items:center;justify-content:center;
        font-weight:800;font-size:34px;cursor:pointer;user-select:none;transition:transform .06s, background .1s, box-shadow .1s}
  .card:active{transform:scale(.98)}
  .card.sel{outline:2px solid var(--accent);background:rgba(125,211,252,.12)}
  .faded{opacity:.6}

  .ops{display:flex;gap:12px;justify-content:center;margin:2px 0 8px}
  .op{padding:10px 14px;border-radius:12px;border:1px solid var(--bd);background:#0e1729;color:#e8eefc;cursor:pointer;font:inherit;min-width:54px;text-align:center}
  .op:disabled{opacity:.4;cursor:not-allowed}

  .row{display:flex;gap:10px;justify-content:center;margin-top:8px;flex-wrap:wrap}
  .btn{padding:10px 14px;border-radius:12px;border:1px solid var(--bd);background:#0e1729;color:#e8eefc;cursor:pointer}
  .btn[disabled]{opacity:.5;cursor:not-allowed}

  .status{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px;margin-top:8px;gap:8px;flex-wrap:wrap}
  .shots{letter-spacing:2px}

  .ok{color:var(--ok)} .err{color:var(--err)}
  .toast{min-height:20px;text-align:center;font-size:14px;margin-top:8px}

  @media(min-width:560px){ .card{width:140px;height:100px;font-size:38px} .diamond{height:420px} }

  @keyframes shake { 0%{transform:translateX(0)} 25%{transform:translateX(-2px)} 50%{transform:translateX(2px)} 75%{transform:translateX(-2px)} 100%{transform:translateX(0)} }
  .shake{animation:shake .15s}
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Make 24 <span id="pnum" class="muted"></span></h1>
    <span class="pill">Attempts <strong id="tries">0/4</strong></span>
  </header>

  <div class="panel">
    <div class="diamond" id="diamond">
      <div class="slot top"><div class="card" data-pos="top"></div></div>
      <div class="slot left"><div class="card" data-pos="left"></div></div>
      <div class="slot right"><div class="card" data-pos="right"></div></div>
      <div class="slot bottom"><div class="card" data-pos="bottom"></div></div>
    </div>

    <div class="ops">
      <button class="op" data-op="+">+</button>
      <button class="op" data-op="/">÷</button>
      <button class="op" data-op="*">×</button>
      <button class="op" data-op="-">−</button>
    </div>

    <div class="row">
      <button id="undo"   class="btn" disabled>Undo</button>
      <button id="reset"  class="btn">Reset</button>
      <button id="submit" class="btn" disabled>Submit</button>
      <button id="share"  class="btn" style="display:none">Share</button>
    </div>

    <div class="status">
      <div id="modeLine" class="muted">Daily puzzle · Target 24</div>
      <div id="shots" class="shots">● ○ ○ ○</div>
      <div id="scoreline" class="muted"></div>
    </div>

    <div id="toast" class="toast muted" aria-live="polite"></div>
  </div>

  <p class="muted" style="margin-top:10px">
    Tap two numbers, then an operator. Use each original number exactly once. When only one card remains, <strong>Submit</strong> to log the attempt.
  </p>
</div>

<script>
(function(){
  // ===== constants & helpers =====
  const TARGET = 24;
  const MAX_TRIES = 4;

  const DAY = Math.floor(Date.UTC(new Date().getUTCFullYear(), new Date().getUTCMonth(), new Date().getUTCDate())/864e5);
  document.getElementById('pnum').textContent = `#${DAY}`;

  const NS = "make24_daily_v1";
  const KEY = k => `${NS}_${k}`;
  const EPS = 1e-6;

  const diamond = document.getElementById('diamond');
  const cardsDom = Array.from(diamond.querySelectorAll('.card'));
  const opsDom   = Array.from(document.querySelectorAll('.op'));
  const undoEl   = document.getElementById('undo');
  const resetEl  = document.getElementById('reset');
  const submitEl = document.getElementById('submit');
  const shareEl  = document.getElementById('share');
  const toastEl  = document.getElementById('toast');
  const triesEl  = document.getElementById('tries');
  const shotsEl  = document.getElementById('shots');
  const scoreline = document.getElementById('scoreline');

  const setToast = (m, cls="muted") => { toastEl.textContent = m; toastEl.className = `toast ${cls}`; };
  const fmt = n => {
    const r = Math.round(n*1000)/1000;
    return Math.abs(r - Math.round(r)) < 1e-9 ? String(Math.round(r)) : String(r);
  };

  // seeded RNG
  function mulberry32(a){ return function(){ let t=a+=0x6D2B79F5; t=Math.imul(t^t>>>15,t|1); t^=t+Math.imul(t^t>>>7,t|61); return ((t^t>>>14)>>>0)/4294967296; }; }
  const rng = mulberry32((DAY ^ 0x9E3779B9)>>>0);
  function ri(a,b){ return Math.floor(rng()*(b-a+1))+a; }

  // weighted letter bag for numbers 1..10 feel (classic 24)
  function generateSet(){ return [ri(1,10),ri(1,10),ri(1,10),ri(1,10)]; }

  // solver
  function solve24(nums){
    const arr = nums.map(n=>({val:n, expr:String(n)}));
    const sols = [];
    function dfs(items){
      if (items.length===1){
        if (Math.abs(items[0].val - TARGET) < EPS){
          const e = items[0].expr;
          sols.push({expr:e, usedOps:new Set(e.replace(/[0-9(). ]/g,'').split(''))});
        }
        return;
      }
      for (let i=0;i<items.length;i++){
        for (let j=i+1;j<items.length;j++){
          const a=items[i], b=items[j];
          const rest = items.filter((_,k)=>k!==i && k!==j);
          const cand = [];
          cand.push({ val:a.val+b.val, expr:`(${a.expr}+${b.expr})` });
          cand.push({ val:a.val*b.val, expr:`(${a.expr}*${b.expr})` });
          cand.push({ val:a.val-b.val, expr:`(${a.expr}-${b.expr})` });
          cand.push({ val:b.val-a.val, expr:`(${b.expr}-${a.expr})` });
          if (Math.abs(b.val)>EPS) cand.push({ val:a.val/b.val, expr:`(${a.expr}/${b.expr})` });
          if (Math.abs(a.val)>EPS) cand.push({ val:b.val/a.val, expr:`(${b.expr}/${a.expr})` });
          for (const c of cand){ if (isFinite(c.val) && Math.abs(c.val) < 1e6) dfs(rest.concat(c)); }
        }
      }
    }
    dfs(arr);
    return { found: sols.length>0, solutions: sols };
  }

  // quality gate: solvable, sum!=24, at least one * or /
  function isGood(nums, solved){
    if (!solved.found) return false;
    if (nums.reduce((a,b)=>a+b,0) === TARGET) return false;
    return !!solved.solutions.find(s=> s.usedOps.has('*') || s.usedOps.has('/'));
  }

  function makePuzzle(seed){
    const r = mulberry32(seed>>>0);
    let tries=0;
    while(tries<400){
      const nums = [1,1,1,1].map(()=>Math.floor(r()*10)+1);
      const solved = solve24(nums);
      if (isGood(nums, solved)){
        const sol = solved.solutions.find(s=>s.usedOps.has('*') || s.usedOps.has('/')) || solved.solutions[0];
        return { nums, solution: sol.expr };
      }
      tries++;
    }
    // fallback
    const nums = generateSet();
    const solved = solve24(nums);
    return { nums, solution: solved.found ? solved.solutions[0].expr : "" };
  }

  // ===== state =====
  let original = []; // [t,l,r,b]
  let items    = []; // current working array order: [top,left,right,bottom] but we’ll track positions
  let posOrder = ['top','left','right','bottom']; // fixed dom positions

  let history = []; // for Undo (stack of items arrays)
  let selectedIdx = []; // indices into items for the two picks
  let tries = 0;
  let done  = false;
  let solutionExpr = "";

  // storage
  function save(){
    localStorage.setItem(KEY("daily"), JSON.stringify({
      day:DAY, original, items, history, selectedIdx, tries, done, solutionExpr
    }));
  }
  function load(){
    try{
      const s = JSON.parse(localStorage.getItem(KEY("daily"))||"{}");
      if (s.day===DAY) return s;
    }catch(_){}
    return null;
  }

  // UI render
  function render(){
    // map items to positions: maintain same ordering (top,left,right,bottom), fill blanks as faded
    const dataByPos = {};
    for (let i=0;i<posOrder.length;i++){
      dataByPos[posOrder[i]] = items[i] ?? null;
    }
    cardsDom.forEach(card=>{
      const pos = card.dataset.pos;
      const data = dataByPos[pos];
      if (data){
        card.textContent = fmt(data.val);
        card.classList.toggle('faded', false);
        card.classList.toggle('sel', selectedIdx.includes(items.indexOf(data)));
      }else{
        card.textContent = "";
        card.classList.add('faded');
        card.classList.remove('sel');
      }
    });

    // ops enabled only when two selected
    const ready = selectedIdx.length===2 && !done;
    opsDom.forEach(b=> b.disabled = !ready);
    undoEl.disabled   = history.length===0 || done;
    resetEl.disabled  = done;
    submitEl.disabled = !(items.length===1 && !done);

    triesEl.textContent = `${tries}/${MAX_TRIES}`;
    const dots = ["●","○","○","○"];
    if (tries>=2) dots[1]="●"; if (tries>=3) dots[2]="●"; if (tries>=4) dots[3]="●";
    shotsEl.textContent = dots.join(" ");
  }

  function setCardsFromOriginal(){
    items = original.map(n=> ({ val:n, expr:String(n) }));
  }

  function initNewDay(){
    const { nums, solution } = makePuzzle((DAY ^ 0x9E3779B9)>>>0);
    // map to diamond: [top,left,right,bottom]
    original = [nums[0], nums[1], nums[2], nums[3]];
    solutionExpr = solution;
    setCardsFromOriginal();
    history = []; selectedIdx = []; tries = 0; done=false;
  }

  function start(){
    const s = load();
    if (s){
      original = s.original;
      items    = s.items;
      history  = s.history || [];
      selectedIdx = s.selectedIdx || [];
      tries    = s.tries || 0;
      done     = !!s.done;
      solutionExpr = s.solutionExpr || "";
    } else {
      initNewDay();
      save();
    }
    render();
    if (done){
      setToast(endText(), "ok"); shareEl.style.display="inline-block";
    } else {
      if (tries>=MAX_TRIES){ done=true; render(); setToast(endText(),"ok"); shareEl.style.display="inline-block"; save(); }
      else { setToast("", "muted"); shareEl.style.display="none"; }
    }
  }

  function endText(){
    const best = window._bestValue ?? null;
    const target = TARGET;
    let close = "";
    if (typeof best === "number"){
      const pct = Math.round((Math.min(best,target)/target)*100);
      close = ` · Best ${fmt(best)} / ${target} (${pct}%)`;
    }
    const ex = solutionExpr ? ` · Example: ${solutionExpr.replaceAll('*','×').replaceAll('/','÷')}` : "";
    return `All attempts used. Come back tomorrow.${ex}`;
  }

  // card interactions
  cardsDom.forEach(card=>{
    card.addEventListener('click', ()=>{
      if (done) return;
      const pos = card.dataset.pos;
      const idx = posOrder.indexOf(pos);
      if (!items[idx]){ card.classList.add('shake'); setTimeout(()=>card.classList.remove('shake'),150); return; }
      const inv = selectedIdx.indexOf(idx);
      if (inv>=0){ selectedIdx.splice(inv,1); }
      else{
        if (selectedIdx.length<2) selectedIdx.push(idx);
        else { selectedIdx = [selectedIdx[1], idx]; }
      }
      render();
    });
  });

  function combine(op){
    if (done || selectedIdx.length!==2) return;
    const i = selectedIdx[0], j = selectedIdx[1];
    const a = items[i], b = items[j];
    if (!a || !b) return;
    let val;
    if      (op==='+') val = a.val + b.val;
    else if (op==='-') val = a.val - b.val;
    else if (op==='*') val = a.val * b.val;
    else if (op==='/'){
      if (Math.abs(b.val)<EPS){ setToast("Cannot divide by zero.", "err"); return; }
      val = a.val / b.val;
    }
    history.push(JSON.parse(JSON.stringify(items))); // save state
    // remove higher index first
    const hi=Math.max(i,j), lo=Math.min(i,j);
    items.splice(hi,1);
    items.splice(lo,1);
    // push result into the first free slot position order
    const freeSlots = posOrder.map((_,idx)=> items[idx] ? null : idx).filter(x=>x!==null);
    const targetSlot = freeSlots.length ? freeSlots[0] : items.length; // fallback
    items.splice(targetSlot,0,{ val, expr:`(${a.expr}${op}${b.expr})` });

    selectedIdx = []; setToast("", ""); render();
  }

  opsDom.forEach(btn=> btn.addEventListener('click', ()=> combine(btn.dataset.op)));

  undoEl.addEventListener('click', ()=>{
    if (!history.length || done) return;
    items = history.pop();
    selectedIdx = [];
    setToast("", ""); render(); save();
  });

  resetEl.addEventListener('click', ()=>{
    if (done) return;
    setCardsFromOriginal(); history=[]; selectedIdx=[];
    setToast("", ""); render(); save();
  });

  function closenessText(val){
    const pct = Math.round((Math.min(val,TARGET)/TARGET)*100);
    const medal = pct>=100 ? "🏆" : (pct>=90 ? "🥇" : (pct>=75 ? "🥈" : (pct>=60 ? "🥉" : "")));
    return `Result ${fmt(val)} / ${TARGET} (${pct}%) ${medal}`;
  }

  submitEl.addEventListener('click', ()=>{
    if (done || items.length!==1) return;
    const val = items[0].val;
    // track best for end text
    const prevBest = window._bestValue ?? -Infinity;
    window._bestValue = Math.max(prevBest, val);

    tries++;
    if (Math.abs(val - TARGET)<EPS){
      done = true;
      setToast(`Perfect! ${closenessText(val)} ✔`, "ok");
      shareEl.style.display="inline-block";
    } else {
      setToast(closenessText(val), "err");
      // reset board for next attempt if any
      if (tries < MAX_TRIES){
        setCardsFromOriginal(); history=[]; selectedIdx=[];
      } else {
        done = true;
        setToast(endText(), "ok");
        shareEl.style.display="inline-block";
      }
    }
    render(); save();
  });

  shareEl.addEventListener('click', async ()=>{
    const best = typeof window._bestValue==="number" ? window._bestValue : null;
    const pct  = best ? Math.round((Math.min(best,TARGET)/TARGET)*100) : 0;
    const medal = pct>=100 ? "🏆" : (pct>=90 ? "🥇" : (pct>=75 ? "🥈" : (pct>=60 ? "🥉" : "")));
    const triesTxt = `${tries}/${MAX_TRIES}`;
    const nums = `[${original.join(", ")}]`;
    const text = `Make 24 #${DAY} — ${triesTxt} tries · Best ${best?fmt(best):"–"}/${TARGET} (${pct}%) ${medal} ${nums}`;
    try{
      if (navigator.share){ await navigator.share({ text }); }
      else { await navigator.clipboard.writeText(text); setToast("Result copied to clipboard.", "ok"); }
    }catch(_){}
  });

  // boot
  start();
})();
</script>
</body>
</html>