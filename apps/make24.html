<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Make 24 | Kapework</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Space+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --cyan: #22d3ee;
            --cyan-dark: #0891b2;
            --cyan-glow: rgba(34, 211, 238, 0.3);
            --bg: #0f172a;
            --card-bg: #1e293b;
            --card-border: #334155;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100dvh;
            padding: 16px;
            padding-bottom: env(safe-area-inset-bottom, 16px);
        }

        /* Header */
        .header {
            width: 100%;
            max-width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            margin-bottom: 16px;
        }

        .puzzle-number {
            font-family: 'Space Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--cyan);
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .puzzle-number:hover {
            opacity: 0.8;
        }

        .streak-display {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1.25rem;
            font-weight: 700;
        }

        .streak-display .fire {
            font-size: 1.5rem;
        }

        .freeze-indicator {
            font-size: 1rem;
            margin-left: 4px;
            opacity: 0.8;
        }

        /* Game Container */
        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 400px;
            gap: 24px;
        }

        /* Current Result Display */
        .result-display {
            font-family: 'Space Mono', monospace;
            font-size: 3rem;
            font-weight: 700;
            color: var(--text);
            min-height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.3s, transform 0.2s;
        }

        .result-display.success {
            color: var(--success);
            transform: scale(1.1);
        }

        .result-display.error {
            color: var(--error);
        }

        /* Diamond Grid Layout - CRITICAL: Using CSS Grid, not absolute positioning */
        .diamond-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 12px;
            width: 280px;
            height: 280px;
        }

        /* Grid slot positions */
        .slot {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slot.top {
            grid-column: 2;
            grid-row: 1;
        }

        .slot.left {
            grid-column: 1;
            grid-row: 2;
        }

        .slot.right {
            grid-column: 3;
            grid-row: 2;
        }

        .slot.bottom {
            grid-column: 2;
            grid-row: 3;
        }

        /* Cards */
        .card {
            width: 80px;
            height: 80px;
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 12px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Mono', monospace;
            font-size: 2rem;
            font-weight: 700;
            color: var(--text);
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
            -webkit-user-select: none;
            user-select: none;
        }

        .card:active {
            transform: scale(0.95);
        }

        .card.selected {
            border-color: var(--cyan);
            box-shadow: 0 0 20px var(--cyan-glow);
            transform: scale(1.05);
        }

        .card.selected.first {
            border-color: var(--cyan);
        }

        .card.selected.second {
            border-color: var(--warning);
            box-shadow: 0 0 20px rgba(245, 158, 11, 0.3);
        }

        .card.used {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }

        /* Operators */
        .operators {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .op-btn {
            width: 56px;
            height: 56px;
            border-radius: 50%;
            border: 2px solid var(--card-border);
            background: var(--card-bg);
            color: var(--text);
            font-size: 1.75rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .op-btn:not(:disabled):hover {
            border-color: var(--cyan);
            background: rgba(34, 211, 238, 0.1);
        }

        .op-btn:not(:disabled):active {
            transform: scale(0.9);
        }

        .op-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Attempts */
        .attempts {
            display: flex;
            gap: 8px;
            justify-content: center;
            margin-top: 8px;
        }

        .attempt-dot {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: var(--card-border);
            transition: background 0.3s;
        }

        .attempt-dot.used {
            background: var(--error);
        }

        .attempt-dot.success {
            background: var(--success);
        }

        /* Buttons */
        .action-buttons {
            display: flex;
            gap: 12px;
            margin-top: 8px;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-family: 'DM Sans', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn-primary {
            background: var(--cyan);
            color: var(--bg);
        }

        .btn-primary:hover {
            background: var(--cyan-dark);
        }

        .btn-secondary {
            background: var(--card-bg);
            color: var(--text);
            border: 1px solid var(--card-border);
        }

        .btn-secondary:hover {
            border-color: var(--cyan);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Message overlay */
        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            border: 2px solid var(--cyan);
            border-radius: 16px;
            padding: 32px;
            text-align: center;
            z-index: 100;
            max-width: 90%;
            width: 320px;
            box-shadow: 0 0 40px var(--cyan-glow);
            display: none;
        }

        .message.show {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .message h2 {
            font-size: 1.5rem;
            margin-bottom: 8px;
        }

        .message p {
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .message .stats {
            font-family: 'Space Mono', monospace;
            font-size: 1.25rem;
            margin: 16px 0;
        }

        /* Archive Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.8);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 16px;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            max-width: 360px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            text-align: center;
            margin-bottom: 16px;
            color: var(--cyan);
        }

        .archive-list {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .archive-item {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            font-family: 'Space Mono', monospace;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .archive-item:hover {
            border-color: var(--cyan);
        }

        .archive-item.completed {
            background: rgba(16, 185, 129, 0.2);
            border-color: var(--success);
        }

        .archive-item.failed {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--error);
        }

        .archive-item.today {
            border-color: var(--cyan);
            box-shadow: 0 0 10px var(--cyan-glow);
        }

        .modal-close {
            display: block;
            width: 100%;
            margin-top: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            cursor: pointer;
        }

        /* Confetti */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Archive mode indicator */
        .archive-banner {
            background: var(--warning);
            color: var(--bg);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            margin-bottom: 8px;
            display: none;
        }

        .archive-banner.show {
            display: block;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="puzzle-number" id="puzzleNumber" title="Tap for archive">#â€”</div>
        <div class="streak-display">
            <span class="fire">ðŸ”¥</span>
            <span id="streakCount">0</span>
            <span class="freeze-indicator" id="freezeIndicator"></span>
        </div>
    </div>

    <div class="archive-banner" id="archiveBanner">
        ðŸ“… Archive Mode
    </div>

    <div class="game-container">
        <div class="result-display" id="resultDisplay">â€”</div>

        <div class="diamond-grid" id="diamondGrid">
            <div class="slot top" id="slot0"></div>
            <div class="slot left" id="slot1"></div>
            <div class="slot right" id="slot2"></div>
            <div class="slot bottom" id="slot3"></div>
        </div>

        <div class="operators" id="operators">
            <button class="op-btn" data-op="+" disabled>+</button>
            <button class="op-btn" data-op="-" disabled>âˆ’</button>
            <button class="op-btn" data-op="*" disabled>Ã—</button>
            <button class="op-btn" data-op="/" disabled>Ã·</button>
        </div>

        <div class="attempts" id="attempts">
            <div class="attempt-dot"></div>
            <div class="attempt-dot"></div>
            <div class="attempt-dot"></div>
            <div class="attempt-dot"></div>
        </div>

        <div class="action-buttons">
            <button class="btn btn-secondary" id="undoBtn" disabled>Undo</button>
            <button class="btn btn-secondary" id="resetBtn">Reset</button>
        </div>
    </div>

    <div class="message" id="successMessage">
        <h2>ðŸŽ‰ Nice!</h2>
        <p>You made 24!</p>
        <div class="stats" id="successStats"></div>
        <button class="btn btn-primary" id="shareBtn">Share</button>
    </div>

    <div class="message" id="failMessage">
        <h2>ðŸ˜¢ Out of attempts</h2>
        <p>Better luck tomorrow!</p>
        <div class="stats" id="failStats"></div>
        <button class="btn btn-primary" id="failShareBtn">Share</button>
    </div>

    <div class="modal-overlay" id="archiveModal">
        <div class="modal">
            <h2>ðŸ“… Archive</h2>
            <div class="archive-list" id="archiveList"></div>
            <button class="modal-close" id="closeArchive">Close</button>
        </div>
    </div>

    <div class="confetti-container" id="confetti"></div>

    <script>
        // Supabase config
        const SUPABASE_URL = 'https://fimsbfcvavpehryvvcho.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpbXNiZmN2YXZwZWhyeXZ2Y2hvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzOTEwMDMsImV4cCI6MjA3MDk2NzAwM30.6uAm_bDPN9aetYaKWA7zCvS8XDEVhmKKxA7RA7YK4JQ';

        // Constants
        const STORAGE_KEY = 'make24_v3';
        const MAX_ATTEMPTS = 4;
        const ARCHIVE_DAYS = 30;
        const STREAK_FREEZE_INTERVAL = 7;

        // Game state
        let gameState = {
            deviceId: null,
            streak: 0,
            freezes: 0,
            lastPlayedDate: null,
            history: {}, // { puzzleNum: { completed: bool, attempts: num, moves: num } }
        };

        let currentPuzzle = {
            numbers: [],
            puzzleNum: 0,
            date: null,
            isArchive: false
        };

        let playState = {
            cards: [], // { value, used, slot }
            selected: [], // indices
            attempts: 0,
            moves: 0,
            moveHistory: [],
            completed: false
        };

        // Seeded RNG (Mulberry32)
        function mulberry32(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        // Get puzzle number from date
        function getPuzzleNumber(date) {
            const epoch = new Date('2025-01-01T00:00:00Z');
            const diff = date - epoch;
            return Math.floor(diff / (24 * 60 * 60 * 1000)) + 1;
        }

        // Get date from puzzle number
        function getDateFromPuzzleNumber(num) {
            const epoch = new Date('2025-01-01T00:00:00Z');
            return new Date(epoch.getTime() + (num - 1) * 24 * 60 * 60 * 1000);
        }

        // Get today's puzzle number (UTC)
        function getTodayPuzzleNumber() {
            const now = new Date();
            const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
            return getPuzzleNumber(utcDate);
        }

        // Generate 4 numbers for a puzzle
        function generatePuzzle(puzzleNum) {
            const rng = mulberry32(puzzleNum * 12345);
            const numbers = [];
            for (let i = 0; i < 4; i++) {
                numbers.push(Math.floor(rng() * 9) + 1); // 1-9
            }
            return numbers;
        }

        // Check if puzzle has a solution (for validation)
        function hasSolution(nums) {
            if (nums.length === 1) return Math.abs(nums[0] - 24) < 0.0001;
            
            for (let i = 0; i < nums.length; i++) {
                for (let j = 0; j < nums.length; j++) {
                    if (i === j) continue;
                    const remaining = nums.filter((_, k) => k !== i && k !== j);
                    const a = nums[i], b = nums[j];
                    
                    const results = [a + b, a - b, a * b];
                    if (b !== 0) results.push(a / b);
                    
                    for (const r of results) {
                        if (hasSolution([...remaining, r])) return true;
                    }
                }
            }
            return false;
        }

        // Device ID
        function getDeviceId() {
            let id = localStorage.getItem('make24_device_id');
            if (!id) {
                id = 'dev_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
                localStorage.setItem('make24_device_id', id);
            }
            return id;
        }

        // Load/save state
        function loadState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    gameState = { ...gameState, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.error('Failed to load state:', e);
            }
            gameState.deviceId = getDeviceId();
        }

        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState));
            } catch (e) {
                console.error('Failed to save state:', e);
            }
        }

        // Streak management
        function updateStreak() {
            const today = getTodayPuzzleNumber();
            const yesterday = today - 1;
            
            if (gameState.lastPlayedDate === today) {
                // Already played today, no change
                return;
            }
            
            if (gameState.lastPlayedDate === yesterday) {
                // Consecutive day - streak continues
            } else if (gameState.lastPlayedDate === yesterday - 1 && gameState.freezes > 0) {
                // Missed one day but have freeze
                gameState.freezes--;
            } else if (gameState.lastPlayedDate && gameState.lastPlayedDate < yesterday) {
                // Streak broken
                gameState.streak = 0;
            }
            
            updateStreakDisplay();
        }

        function incrementStreak() {
            gameState.streak++;
            gameState.lastPlayedDate = currentPuzzle.puzzleNum;
            
            // Award freeze every 7 days
            if (gameState.streak > 0 && gameState.streak % STREAK_FREEZE_INTERVAL === 0) {
                gameState.freezes++;
            }
            
            saveState();
            updateStreakDisplay();
        }

        function updateStreakDisplay() {
            document.getElementById('streakCount').textContent = gameState.streak;
            const freezeEl = document.getElementById('freezeIndicator');
            freezeEl.textContent = gameState.freezes > 0 ? 'â„ï¸'.repeat(Math.min(gameState.freezes, 3)) : '';
        }

        // Initialize puzzle
        function initPuzzle(puzzleNum, isArchive = false) {
            currentPuzzle.puzzleNum = puzzleNum;
            currentPuzzle.numbers = generatePuzzle(puzzleNum);
            currentPuzzle.isArchive = isArchive;
            currentPuzzle.date = getDateFromPuzzleNumber(puzzleNum);
            
            // Check history
            const history = gameState.history[puzzleNum];
            if (history && history.completed) {
                playState.completed = true;
                playState.attempts = history.attempts;
                playState.moves = history.moves;
            } else if (history) {
                playState.attempts = history.attempts;
            } else {
                playState.attempts = 0;
                playState.completed = false;
            }
            
            resetPlay();
            updateUI();
        }

        function resetPlay() {
            playState.cards = currentPuzzle.numbers.map((v, i) => ({
                value: v,
                used: false,
                slot: i
            }));
            playState.selected = [];
            playState.moveHistory = [];
            
            renderCards();
            updateOperators();
            updateResult();
        }

        // Render cards into grid slots
        function renderCards() {
            const slots = ['slot0', 'slot1', 'slot2', 'slot3'];
            
            slots.forEach((slotId, i) => {
                const slot = document.getElementById(slotId);
                slot.innerHTML = '';
                
                const cardData = playState.cards.find(c => c.slot === i && !c.used);
                if (cardData) {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.textContent = formatNumber(cardData.value);
                    card.dataset.index = playState.cards.indexOf(cardData);
                    
                    const cardIndex = playState.cards.indexOf(cardData);
                    if (playState.selected.includes(cardIndex)) {
                        card.classList.add('selected');
                        if (playState.selected[0] === cardIndex) {
                            card.classList.add('first');
                        } else {
                            card.classList.add('second');
                        }
                    }
                    
                    card.addEventListener('click', () => selectCard(cardIndex));
                    slot.appendChild(card);
                }
            });
        }

        function formatNumber(n) {
            if (Number.isInteger(n)) return n.toString();
            return n.toFixed(2).replace(/\.?0+$/, '');
        }

        function selectCard(index) {
            if (playState.completed) return;
            if (playState.cards[index].used) return;
            
            const pos = playState.selected.indexOf(index);
            if (pos !== -1) {
                playState.selected.splice(pos, 1);
            } else if (playState.selected.length < 2) {
                playState.selected.push(index);
            }
            
            renderCards();
            updateOperators();
        }

        function updateOperators() {
            const btns = document.querySelectorAll('.op-btn');
            const enabled = playState.selected.length === 2 && !playState.completed;
            btns.forEach(btn => btn.disabled = !enabled);
        }

        function applyOperation(op) {
            if (playState.selected.length !== 2 || playState.completed) return;
            
            const [i, j] = playState.selected;
            const a = playState.cards[i].value;
            const b = playState.cards[j].value;
            
            let result;
            switch (op) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/': 
                    if (b === 0) return;
                    result = a / b;
                    break;
            }
            
            // Save state for undo
            playState.moveHistory.push({
                cards: JSON.parse(JSON.stringify(playState.cards)),
                selected: [...playState.selected]
            });
            
            // Mark cards as used
            playState.cards[i].used = true;
            playState.cards[j].used = true;
            
            // Find empty slot (prefer first card's slot)
            const emptySlot = playState.cards[i].slot;
            
            // Create new card
            playState.cards.push({
                value: result,
                used: false,
                slot: emptySlot
            });
            
            playState.selected = [];
            playState.moves++;
            
            renderCards();
            updateOperators();
            updateResult();
            document.getElementById('undoBtn').disabled = false;
            
            // Check for win/lose
            checkGameState();
        }

        function undo() {
            if (playState.moveHistory.length === 0 || playState.completed) return;
            
            const prev = playState.moveHistory.pop();
            playState.cards = prev.cards;
            playState.selected = prev.selected;
            playState.moves--;
            
            renderCards();
            updateOperators();
            updateResult();
            
            if (playState.moveHistory.length === 0) {
                document.getElementById('undoBtn').disabled = true;
            }
        }

        function updateResult() {
            const remaining = playState.cards.filter(c => !c.used);
            const display = document.getElementById('resultDisplay');
            
            if (remaining.length === 1) {
                const val = remaining[0].value;
                display.textContent = formatNumber(val);
                if (Math.abs(val - 24) < 0.0001) {
                    display.classList.add('success');
                    display.classList.remove('error');
                } else {
                    display.classList.remove('success');
                    display.classList.add('error');
                }
            } else {
                display.textContent = 'â€”';
                display.classList.remove('success', 'error');
            }
        }

        function checkGameState() {
            const remaining = playState.cards.filter(c => !c.used);
            
            if (remaining.length === 1) {
                const val = remaining[0].value;
                
                if (Math.abs(val - 24) < 0.0001) {
                    // Win!
                    handleWin();
                } else {
                    // Wrong answer
                    handleWrongAnswer();
                }
            }
        }

        function handleWin() {
            playState.completed = true;
            playState.attempts++;
            
            // Update history
            gameState.history[currentPuzzle.puzzleNum] = {
                completed: true,
                attempts: playState.attempts,
                moves: playState.moves
            };
            
            // Update streak only for today's puzzle
            if (!currentPuzzle.isArchive) {
                incrementStreak();
            }
            
            saveState();
            trackPlay(true);
            
            // Show success
            updateAttempts();
            showConfetti();
            
            const stats = document.getElementById('successStats');
            stats.innerHTML = `Moves: ${playState.moves}<br>Attempts: ${playState.attempts}/${MAX_ATTEMPTS}`;
            
            setTimeout(() => {
                document.getElementById('successMessage').classList.add('show');
            }, 500);
        }

        function handleWrongAnswer() {
            playState.attempts++;
            
            // Update history
            if (!gameState.history[currentPuzzle.puzzleNum]) {
                gameState.history[currentPuzzle.puzzleNum] = { completed: false, attempts: 0 };
            }
            gameState.history[currentPuzzle.puzzleNum].attempts = playState.attempts;
            saveState();
            
            updateAttempts();
            
            if (playState.attempts >= MAX_ATTEMPTS) {
                // Out of attempts
                playState.completed = true;
                trackPlay(false);
                
                const stats = document.getElementById('failStats');
                stats.innerHTML = `The numbers were: ${currentPuzzle.numbers.join(', ')}`;
                
                setTimeout(() => {
                    document.getElementById('failMessage').classList.add('show');
                }, 500);
            } else {
                // Reset for next attempt
                setTimeout(() => {
                    resetPlay();
                }, 800);
            }
        }

        function updateAttempts() {
            const dots = document.querySelectorAll('.attempt-dot');
            dots.forEach((dot, i) => {
                dot.classList.remove('used', 'success');
                if (i < playState.attempts) {
                    if (i === playState.attempts - 1 && playState.completed && 
                        gameState.history[currentPuzzle.puzzleNum]?.completed) {
                        dot.classList.add('success');
                    } else {
                        dot.classList.add('used');
                    }
                }
            });
        }

        function updateUI() {
            // Puzzle number
            document.getElementById('puzzleNumber').textContent = `#${currentPuzzle.puzzleNum}`;
            
            // Archive banner
            document.getElementById('archiveBanner').classList.toggle('show', currentPuzzle.isArchive);
            
            // Streak
            updateStreakDisplay();
            
            // Attempts
            updateAttempts();
            
            // Undo button
            document.getElementById('undoBtn').disabled = true;
        }

        // Confetti
        function showConfetti() {
            const container = document.getElementById('confetti');
            const colors = ['#22d3ee', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6'];
            
            for (let i = 0; i < 50; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animation = `confetti-fall ${1.5 + Math.random()}s ease-out forwards`;
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
                container.appendChild(confetti);
            }
            
            setTimeout(() => {
                container.innerHTML = '';
            }, 3000);
        }

        // Share
        function generateShareText() {
            const emoji = playState.completed && gameState.history[currentPuzzle.puzzleNum]?.completed 
                ? 'âœ…' : 'âŒ';
            const nums = currentPuzzle.numbers.join(' ');
            
            let text = `Make 24 #${currentPuzzle.puzzleNum} ${emoji}\n`;
            text += `Numbers: ${nums}\n`;
            
            if (gameState.history[currentPuzzle.puzzleNum]?.completed) {
                text += `Moves: ${playState.moves} | Attempts: ${playState.attempts}/${MAX_ATTEMPTS}\n`;
            } else {
                text += `${playState.attempts}/${MAX_ATTEMPTS} attempts\n`;
            }
            
            text += `ðŸ”¥ Streak: ${gameState.streak}\n`;
            text += `kapework.com/apps/make24`;
            
            return text;
        }

        function share() {
            const text = generateShareText();
            
            if (navigator.share) {
                navigator.share({ text }).catch(() => {
                    copyToClipboard(text);
                });
            } else {
                copyToClipboard(text);
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard!');
            }).catch(() => {
                alert(text);
            });
        }

        // Archive
        function showArchive() {
            const modal = document.getElementById('archiveModal');
            const list = document.getElementById('archiveList');
            list.innerHTML = '';
            
            const today = getTodayPuzzleNumber();
            
            for (let i = 0; i < ARCHIVE_DAYS; i++) {
                const num = today - i;
                if (num < 1) continue;
                
                const item = document.createElement('div');
                item.className = 'archive-item';
                item.textContent = num;
                
                const history = gameState.history[num];
                if (history?.completed) {
                    item.classList.add('completed');
                } else if (history?.attempts >= MAX_ATTEMPTS) {
                    item.classList.add('failed');
                }
                
                if (num === today) {
                    item.classList.add('today');
                }
                
                item.addEventListener('click', () => {
                    modal.classList.remove('show');
                    initPuzzle(num, num !== today);
                });
                
                list.appendChild(item);
            }
            
            modal.classList.add('show');
        }

        // Track play to Supabase
        async function trackPlay(success) {
            try {
                const response = await fetch(`${SUPABASE_URL}/rest/v1/plays`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                        'Prefer': 'return=minimal'
                    },
                    body: JSON.stringify({
                        slug: `make24-${currentPuzzle.puzzleNum}`,
                        device_id: gameState.deviceId,
                        metadata: {
                            success,
                            attempts: playState.attempts,
                            moves: playState.moves,
                            numbers: currentPuzzle.numbers,
                            isArchive: currentPuzzle.isArchive,
                            streak: gameState.streak
                        }
                    })
                });
            } catch (e) {
                console.error('Failed to track play:', e);
            }
        }

        // Event listeners
        document.querySelectorAll('.op-btn').forEach(btn => {
            btn.addEventListener('click', () => applyOperation(btn.dataset.op));
        });

        document.getElementById('undoBtn').addEventListener('click', undo);
        document.getElementById('resetBtn').addEventListener('click', resetPlay);
        document.getElementById('puzzleNumber').addEventListener('click', showArchive);
        document.getElementById('closeArchive').addEventListener('click', () => {
            document.getElementById('archiveModal').classList.remove('show');
        });
        document.getElementById('shareBtn').addEventListener('click', () => {
            document.getElementById('successMessage').classList.remove('show');
            share();
        });
        document.getElementById('failShareBtn').addEventListener('click', () => {
            document.getElementById('failMessage').classList.remove('show');
            share();
        });

        // Close modals on overlay click
        document.getElementById('archiveModal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                e.currentTarget.classList.remove('show');
            }
        });

        // Initialize
        loadState();
        updateStreak();
        initPuzzle(getTodayPuzzleNumber(), false);
    </script>
</body>
</html>
