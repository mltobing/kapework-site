<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
<title>Tiltrix</title>
<style>
  :root { --bd:#e5e7eb; --muted:#6b7280; --ink:#111827; --bg:#ffffff; }
  *{box-sizing:border-box; -webkit-tap-highlight-color: transparent;}
  html,body{margin:0;height:100%;background:var(--bg);color:var(--ink);font:16px system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .wrap{max-width:520px;margin:0 auto;padding:12px 12px 72px;position:relative}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px}
  h1{font-size:20px;margin:0}
  .meta{font-size:12px;color:var(--muted)}
  .board{display:flex;justify-content:center;margin-top:12px}
  canvas{border:1px solid var(--bd);border-radius:14px;background:#0b1220;display:block;touch-action:none}
  .hud{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
  .pill{display:inline-flex;gap:6px;align-items:center;padding:6px 10px;border:1px solid var(--bd);border-radius:999px;background:#fff;box-shadow:0 2px 8px rgba(0,0,0,.04)}
  .btn{padding:6px 10px;border:1px solid var(--bd);border-radius:12px;background:#fff;cursor:pointer}
  .hint{margin-top:10px;color:var(--muted);font-size:12px;line-height:1.3}
  .floating{position:fixed;bottom:12px;right:12px;z-index:9999;padding:10px 12px;border-radius:12px;border:1px solid var(--bd);background:#fff;box-shadow:0 2px 12px rgba(0,0,0,.1);font:14px system-ui}
  .floating.secondary{right:120px}
  @media (min-width:420px){ canvas{width:300px;height:600px} }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>Tiltrix</h1>
      <div class="pill"><span>Score:</span><strong id="score">0</strong></div>
    </header>
    <div class="meta">Tilt left/right to move · Tilt forward to drop · <strong>Twist your wrist</strong> to rotate · Tap left=⟲, right=⟳</div>
    <div class="board"><canvas id="c" width="240" height="480" aria-label="tilt tetris board"></canvas></div>
    <div class="hud">
      <button id="restart" class="btn">Restart</button>
      <div class="pill"><span>Lines:</span><strong id="lines">0</strong></div>
    </div>
    <p class="hint">Tap <strong>Enable Tilt</strong> and hold the phone naturally, then press <strong>Calibrate</strong> if needed.</p>
  </div>

  <!-- === GAME ========================================================= -->
  <script>
  (function(){
    const COLS=10, ROWS=20, SIZE=24;
    const canvas = document.getElementById('c');
    const ctx = canvas.getContext('2d');
    const scoreEl = document.getElementById('score');
    const linesEl  = document.getElementById('lines');
    const restartBtn = document.getElementById('restart');

    const COLORS = { I:'#6ee7b7', O:'#fde68a', T:'#c4b5fd', S:'#86efac', Z:'#fca5a5', J:'#93c5fd', L:'#fdba74' };
    const SHAPES = {
      I:[[[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],[[0,0,1,0],[0,0,1,0],[0,0,1,0],[0,0,1,0]],[[0,0,0,0],[0,0,0,0],[1,1,1,1],[0,0,0,0]],[[0,1,0,0],[0,1,0,0],[0,1,0,0],[0,1,0,0]]],
      O:[[[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],[[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],[[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],[[0,1,1,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]]],
      T:[[[0,1,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],[[0,1,0,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],[[0,0,0,0],[1,1,1,0],[0,1,0,0],[0,0,0,0]],[[0,1,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]]],
      S:[[[0,1,1,0],[1,1,0,0],[0,0,0,0],[0,0,0,0]],[[0,1,0,0],[0,1,1,0],[0,0,1,0],[0,0,0,0]],[[0,0,0,0],[0,1,1,0],[1,1,0,0],[0,0,0,0]],[[1,0,0,0],[1,1,0,0],[0,1,0,0],[0,0,0,0]]],
      Z:[[[1,1,0,0],[0,1,1,0],[0,0,0,0],[0,0,0,0]],[[0,0,1,0],[0,1,1,0],[0,1,0,0],[0,0,0,0]],[[0,0,0,0],[1,1,0,0],[0,1,1,0],[0,0,0,0]],[[0,1,0,0],[1,1,0,0],[1,0,0,0],[0,0,0,0]]],
      J:[[[1,0,0,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],[[0,1,1,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]],[[0,0,0,0],[1,1,1,0],[0,0,1,0],[0,0,0,0]],[[0,1,0,0],[0,1,0,0],[1,1,0,0],[0,0,0,0]]],
      L:[[[0,0,1,0],[1,1,1,0],[0,0,0,0],[0,0,0,0]],[[0,1,0,0],[0,1,0,0],[0,1,1,0],[0,0,0,0]],[[0,0,0,0],[1,1,1,0],[1,0,0,0],[0,0,0,0]],[[1,1,0,0],[0,1,0,0],[0,1,0,0],[0,0,0,0]]]
    };
    const BAG = ['I','O','T','S','Z','J','L'];

    let board, piece, nextBag, score, lines, gameOver=false;
    let dropInterval = 600;   // ms (normal)
    let lastDrop = performance.now();

    function newBoard(){ board = Array.from({length:ROWS}, ()=>Array(COLS).fill(null)); }
    function randBag(){ const a=BAG.slice(); for (let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]]} return a; }
    function spawn(){
      if (!nextBag.length) nextBag = randBag();
      const t = nextBag.pop();
      piece = { t, r:0, x:3, y:0, m:SHAPES[t][0], c:COLORS[t] };
      if (collide(piece, board)) gameOver = true;
    }
    function rotate(p,dir){
      const r=(p.r+(dir>0?1:3))%4, m=SHAPES[p.t][r];
      const test={...p,r,m};
      if (!collide(test,board)) return Object.assign(p,test);
      test.x=p.x+1; if (!collide(test,board)) return Object.assign(p,test);
      test.x=p.x-2; if (!collide(test,board)) return Object.assign(p,test);
    }
    function collide(p,b){
      for (let y=0;y<4;y++) for (let x=0;x<4;x++){
        if (!p.m[y][x]) continue;
        const nx=p.x+x, ny=p.y+y;
        if (nx<0 || nx>=COLS || ny>=ROWS) return true;
        if (ny>=0 && b[ny][nx]) return true;
      }
      return false;
    }
    function merge(p,b){ for (let y=0;y<4;y++) for (let x=0;x<4;x++) if (p.m[y][x] && p.y+y>=0) b[p.y+y][p.x+x]=p.c; }
    function clearLines(){
      let cleared=0;
      for (let y=ROWS-1;y>=0;y--){
        if (board[y].every(Boolean)){ board.splice(y,1); board.unshift(Array(COLS).fill(null)); cleared++; y++; }
      }
      if (cleared){ lines+=cleared; score+=[0,100,300,500,800][cleared]||0; }
    }
    function move(dx){ const t={...piece,x:piece.x+dx}; if (!collide(t,board)) piece.x+=dx; }
    function setFallSpeed(mode){ dropInterval = (mode==="fast")?50:600; }
    function hardDrop(){ if (gameOver) return; while(!collide({...piece,y:piece.y+1},board)) piece.y++; tickLock(); }
    function tick(){
      const now=performance.now();
      if (now-lastDrop>dropInterval){ lastDrop=now; const t={...piece,y:piece.y+1}; if(!collide(t,board)) piece.y++; else tickLock(); }
      draw(); if (!gameOver) requestAnimationFrame(tick); else drawGameOver();
    }
    function tickLock(){ merge(piece,board); clearLines(); spawn(); }
    function drawCell(x,y,c){ const px=x*SIZE,py=y*SIZE; ctx.fillStyle='#0b1220'; ctx.fillRect(px,py,SIZE,SIZE); if(c){ctx.fillStyle=c; ctx.fillRect(px+1,py+1,SIZE-2,SIZE-2); ctx.fillStyle='rgba(255,255,255,.15)'; ctx.fillRect(px+1,py+1,SIZE-2,4);} ctx.strokeStyle='rgba(255,255,255,.06)'; ctx.strokeRect(px+0.5,py+0.5,SIZE-1,SIZE-1); }
    function draw(){ ctx.clearRect(0,0,canvas.width,canvas.height); for(let y=0;y<ROWS;y++)for(let x=0;x<COLS;x++)drawCell(x,y,board[y][x]); for(let y=0;y<4;y++)for(let x=0;x<4;x++) if(piece.m[y][x]){const gx=piece.x+x,gy=piece.y+y; if(gy>=0) drawCell(gx,gy,piece.c);} scoreEl.textContent=score; linesEl.textContent=lines; }
    function drawGameOver(){ ctx.fillStyle='rgba(0,0,0,.5)'; ctx.fillRect(0,0,canvas.width,canvas.height); ctx.fillStyle='#fff'; ctx.font='bold 20px system-ui'; ctx.textAlign='center'; ctx.fillText('Game Over', canvas.width/2, canvas.height/2-8); ctx.font='14px system-ui'; ctx.fillText('Tap Restart', canvas.width/2, canvas.height/2+16); }

    function start(){ newBoard(); nextBag=randBag(); score=0; lines=0; gameOver=false; spawn(); lastDrop=performance.now(); requestAnimationFrame(tick); }
    restartBtn.addEventListener('click', start);
    canvas.addEventListener('click', ()=>{ if (gameOver) start(); });

    // Touch rotate: left half = CCW, right half = CW
    canvas.addEventListener('pointerdown', (e)=>{
      const r=canvas.getBoundingClientRect(); const x=e.clientX-r.left;
      rotate(piece, x<r.width/2 ? -1 : +1);
    });

    // Expose for tilt script
    window.__tiltrixControls = {
      move: (dx)=>move(dx),
      setFallSpeed: (m)=>setFallSpeed(m),
      hardDrop: ()=>hardDrop(),
      rotate: (dir)=>rotate(piece,dir) // +1 CW, -1 CCW
    };

    start();
  })();
  </script>

  <!-- === TILT CONTROLS: L/R move, forward drop, WRIST-TWIST rotate ====== -->
  <script>
  (function(){
    const G = window.__tiltrixControls; if (!G) return;

    // Hook bridge
    const HOOKS = {
      moveLeft:  () => G.move(-1),
      moveRight: () => G.move(+1),
      startSoftDrop: () => G.setFallSpeed("fast"),
      stopSoftDrop:  () => G.setFallSpeed("normal"),
      hardDrop:  () => G.hardDrop(),
      rotateCW:  () => G.rotate(+1),
      rotateCCW: () => G.rotate(-1)
    };

    // Floating buttons
    function makeButton(text, onClick, rightPx) {
      const b = document.createElement("button");
      b.textContent = text; b.className = "floating" + (rightPx?" secondary":"");
      if (rightPx) b.style.right = rightPx;
      b.addEventListener("click", onClick);
      document.body.appendChild(b);
      return b;
    }

    // Sensitivity (steadier defaults)
    const LR_TILT = 12;   // deg to start moving
    const LR_DAS  = 180;  // ms before auto-repeat
    const LR_RPT  = 85;   // ms repeat
    const FB_SOFT = 10;   // deg beta for soft drop
    const FB_HARD = 26;   // deg beta for hard drop
    const HYS     = 5;
    const SMOOTH  = 0.25;

    // Wrist-twist thresholds (gyroscope z-axis, deg/sec)
    const TWIST_THRESH = 140;   // how brisk the twist must be
    const TWIST_COOLDOWN = 220; // ms between rotations
    const INVERT_TWIST = false; // flip if directions feel reversed on your device

    // State
    let baseBeta=0, baseGamma=0, fBeta=0, fGamma=0;
    let lrState=0, lrTimer=null, lrRpt=null;
    let softDropping=false, hardDroppedLatch=false;
    let lastTwistTime=0;

    function stopLR(){ if (lrTimer){clearTimeout(lrTimer);lrTimer=null} if(lrRpt){clearInterval(lrRpt);lrRpt=null} }
    function startLR(dir){ stopLR(); (dir<0?HOOKS.moveLeft:HOOKS.moveRight)(); lrTimer=setTimeout(()=>{ lrRpt=setInterval(()=> (dir<0?HOOKS.moveLeft:HOOKS.moveRight)(), LR_RPT); }, LR_DAS); }
    function setSoftDrop(on){ if (on && !softDropping){HOOKS.startSoftDrop(); softDropping=true;} if (!on && softDropping){HOOKS.stopSoftDrop(); softDropping=false;} }
    function calibrate(beta,gamma){ baseBeta=beta; baseGamma=gamma; stopLR(); lrState=0; setSoftDrop(false); hardDroppedLatch=false; }

    // DeviceOrientation: tilt for L/R + drop
    function bindOrientation(){
      window.addEventListener("deviceorientation",(e)=>{
        const beta = e.beta ?? 0;   // forward/back
        const gamma = e.gamma ?? 0; // left/right
        const dB = beta - baseBeta, dG = gamma - baseGamma;
        fBeta  += (dB - fBeta)  * SMOOTH;
        fGamma += (dG - fGamma) * SMOOTH;

        // Move left/right
        const wantLR = (fGamma > LR_TILT) ? 1 : (fGamma < -LR_TILT ? -1 : 0);
        if (wantLR !== lrState){ lrState = wantLR; stopLR(); if (lrState!==0) startLR(lrState); }

        // Drop
        const forward = fBeta;
        if (forward > FB_HARD && !hardDroppedLatch){ HOOKS.hardDrop(); hardDroppedLatch=true; }
        else if (forward < FB_HARD - HYS){ hardDroppedLatch=false; }
        setSoftDrop(forward > FB_SOFT && forward <= FB_HARD - HYS);
      }, { passive:true });
    }

    // DeviceMotion: WRIST-TWIST rotate using rotationRate.alpha (z axis)
    function bindMotion(){
      window.addEventListener("devicemotion",(e)=>{
        const rr = e.rotationRate || {};
        const z = rr.alpha || 0; // deg/sec around screen normal
        const now = performance.now();
        if (Math.abs(z) >= TWIST_THRESH && (now - lastTwistTime) > TWIST_COOLDOWN){
          const cw = INVERT_TWIST ? (z < 0) : (z > 0);
          cw ? HOOKS.rotateCW() : HOOKS.rotateCCW();
          lastTwistTime = now;
        }
      }, { passive:true });
    }

    // Permission + calibration
    async function requestMotion(){
      try{
        const needDM = typeof DeviceMotionEvent !== "undefined" && typeof DeviceMotionEvent.requestPermission === "function";
        const needDO = typeof DeviceOrientationEvent !== "undefined" && typeof DeviceOrientationEvent.requestPermission === "function";
        if (needDM) { const r = await DeviceMotionEvent.requestPermission(); if (r !== "granted") throw new Error("Motion denied"); }
        if (needDO) { const r2 = await DeviceOrientationEvent.requestPermission(); if (r2 !== "granted") throw new Error("Orientation denied"); }
        const once = (e)=>{ calibrate(e.beta||0, e.gamma||0); window.removeEventListener("deviceorientation", once); };
        window.addEventListener("deviceorientation", once, { passive:true });
        bindOrientation(); bindMotion();
        permBtn.remove(); calibBtn.style.display="block";
      }catch(err){ alert("Tilt access not granted. You can keep playing with taps."); console.warn(err); }
    }

    const permBtn  = makeButton("Enable Tilt", requestMotion);
    const calibBtn = makeButton("Calibrate", ()=>{
      const once = (e)=>{ calibrate(e.beta||0, e.gamma||0); window.removeEventListener("deviceorientation", once); };
      window.addEventListener("deviceorientation", once, { passive:true });
    }, "120px");
    calibBtn.style.display="none";

    document.addEventListener("visibilitychange", ()=>{ if (document.hidden){ stopLR(); setSoftDrop(false); } });
  })();
  </script>
</body>
</html>