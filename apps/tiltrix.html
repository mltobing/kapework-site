<!doctype html>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no">
<title>Tiltrix — Kapework Vibe Lab</title>
<style>
  html,body{height:100svh;margin:0;overflow:hidden;background:#f8f7f4;color:#2b221b;
            font:16px/1.55 system-ui,-apple-system,Segoe UI,Roboto,sans-serif}
  .wrap{height:100%;display:grid;place-items:center}
  .hud{position:fixed;top:8px;left:8px;right:8px;display:flex;justify-content:space-between;
       font-weight:800;opacity:.8;pointer-events:none}
  canvas{touch-action:none;image-rendering:pixelated}
  .start{position:fixed;inset:0;display:grid;place-items:center;background:rgba(248,247,244,.95)}
  .card{background:#fff;border:1px solid #ece8e3;border-radius:14px;box-shadow:0 10px 24px rgba(0,0,0,.06);
        padding:16px;text-align:center;max-width:420px}
  .btn{margin-top:10px;padding:10px 14px;border-radius:12px;border:1px solid #e0dcd6;background:#fff;font-weight:800}
  .btn.primary{background:#b67b50;color:#fff;border-color:#a06d47}
  a{color:inherit;text-decoration:none;border-bottom:1px dashed #c0b3a6}
</style>
<body>
<div class="wrap"><canvas id="cv" width="320" height="640" aria-label="Tiltrix game board"></canvas></div>
<div class="hud"><div id="score">Lines: 0</div><div><a href="/apps/">Vibe Lab</a></div></div>

<!-- Start / permission overlay -->
<div id="gate" class="start">
  <div class="card">
    <h2 style="margin:0 0 6px">Tiltrix</h2>
    <div style="opacity:.8">Tilt left/right to move. Tap to rotate. Swipe down to drop.</div>
    <button id="tilt" class="btn primary">Enable tilt & start</button>
    <button id="nosensor" class="btn">Start without tilt</button>
    <div style="opacity:.6;margin-top:8px;font-size:.9rem">
      Tip: add <code>?mode=daily</code> for today’s seeded sequence.
    </div>
  </div>
</div>

<script>
/* ----------- utils & seeded RNG ----------- */
function lcg(seed){let s=seed>>>0;return()=>((s=(s*1664525+1013904223)>>>0)/4294967296);}
function daySeed(){return Number(new Date().toISOString().slice(0,10).replace(/-/g,''));}
const seeded = new URLSearchParams(location.search).get('mode')==='daily' ? lcg(daySeed()) : Math.random;

/* ----------- board & pieces ----------- */
const COLS=10, ROWS=20;
const COLORS=['#ddd','#5cc8ff','#ffd166','#06d6a0','#ef476f','#8d8bfe','#ffa3a3','#7bdff2']; // bright
const SHAPES=[ // I,O,T,S,Z,J,L (4x4 matrices)
 [[0,0,0,0],[1,1,1,1],[0,0,0,0],[0,0,0,0]],
 [[2,2],[2,2]],
 [[0,3,0],[3,3,3],[0,0,0]],
 [[0,4,4],[4,4,0],[0,0,0]],
 [[5,5,0],[0,5,5],[0,0,0]],
 [[6,0,0],[6,6,6],[0,0,0]],
 [[0,0,7],[7,7,7],[0,0,0]]
];

function emptyBoard(){return Array.from({length:ROWS},()=>Array(COLS).fill(0));}
let board = emptyBoard();

/* 7-bag generator */
function bag(rand=seeded){
  const ids=[0,1,2,3,4,5,6]; const out=[];
  while(ids.length){ out.push(ids.splice(Math.floor(rand()*ids.length),1)[0]); }
  return out;
}
let queue=[]; function nextId(){ if(!queue.length) queue=bag(); return queue.shift(); }

/* piece object */
function spawn(){
  const id=nextId(); const raw=SHAPES[id];
  const shape = raw.map(r=>r.slice()); // deep copy
  // position
  const size = shape.length;
  return {id,shape,x: Math.floor((COLS-size)/2), y: -1};
}

/* collisions */
function collide(b, shape, offx, offy){
  for(let y=0;y<shape.length;y++){
    for(let x=0;x<shape[y].length;x++){
      const v=shape[y][x]; if(!v) continue;
      const nx=offx+x, ny=offy+y;
      if(ny<0) continue; // above board allowed
      if(nx<0||nx>=COLS||ny>=ROWS) return true;
      if(b[ny][nx]) return true;
    }
  } return false;
}

/* rotation with simple kicks */
function rot(shape, dir){
  const N=shape.length, out=Array.from({length:N},()=>Array(N).fill(0));
  for(let y=0;y<N;y++) for(let x=0;x<N;x++)
    out[y][x] = dir>0 ? (shape[N-1-x][y]||0) : (shape[x][N-1-y]||0);
  return out;
}
function tryRotate(p,dir){
  const r=rot(p.shape,dir);
  if(!collide(board,r,p.x,p.y)){ p.shape=r; return true; }
  for(const k of [-1,1,-2,2]) if(!collide(board,r,p.x+k,p.y)){ p.x+=k; p.shape=r; return true; }
  return false;
}

/* merge, clear */
function merge(b,p){
  const s=p.shape;
  for(let y=0;y<s.length;y++)
    for(let x=0;x<s[y].length;x++){
      const v=s[y][x]; if(!v) continue;
      const ny=p.y+y, nx=p.x+x; if(ny>=0) b[ny][nx]=v;
    }
}
function clearLines(){
  let cleared=0;
  for(let y=ROWS-1;y>=0;y--){
    if(board[y].every(v=>v)){
      board.splice(y,1);
      board.unshift(Array(COLS).fill(0));
      cleared++; y++;
    }
  } return cleared;
}

/* ----------- rendering ----------- */
const cv=document.getElementById('cv'), ctx=cv.getContext('2d');
function fit(){
  // compute cell to fill screen height with minimal margins
  const W=innerWidth, H=innerHeight;
  const cell = Math.floor(Math.min(W/COLS, H/ROWS));
  cv.width = cell*COLS; cv.height = cell*ROWS;
  ctx.imageSmoothingEnabled=false;
}
addEventListener('resize', fit); fit();

function drawCell(x,y,c){ ctx.fillStyle=COLORS[c]; ctx.fillRect(x,y,1,1);
  ctx.strokeStyle='rgba(0,0,0,.06)'; ctx.strokeRect(x+.02,y+.02,.96,.96); }
function draw(){
  ctx.save(); const s = cv.width/COLS; ctx.scale(s,s); ctx.clearRect(0,0,COLS,ROWS);
  // board
  for(let y=0;y<ROWS;y++) for(let x=0;x<COLS;x++){ const v=board[y][x]; if(v) drawCell(x,y,v); }
  // piece
  const s2=piece.shape;
  for(let y=0;y<s2.length;y++) for(let x=0;x<s2[y].length;x++){
    const v=s2[y][x]; if(!v) continue;
    const ny=piece.y+y, nx=piece.x+x; if(ny>=0) drawCell(nx,ny,v);
  }
  ctx.restore();
}

/* ----------- input: tilt + gestures ----------- */
let useTilt=false, gamma=0;
let lastDir=0, nextMoveAt=0, DAS=150, ARR=60;

function enableTilt(){
  function ok(){ useTilt=true; document.getElementById('gate').style.display='none'; }
  const DME=window.DeviceMotionEvent, DOE=window.DeviceOrientationEvent;
  if(DOE && typeof DOE.requestPermission==='function'){
    DOE.requestPermission().then(s=>{ if(s==='granted') { addTilt(); ok(); } else { ok(); }});
  }else if(DOE){ addTilt(); ok(); }
  else { ok(); }
}
function addTilt(){
  addEventListener('deviceorientation', e=>{ if(typeof e.gamma==='number') gamma=e.gamma; });
}
document.getElementById('tilt').onclick=enableTilt;
document.getElementById('nosensor').onclick=()=>{ document.getElementById('gate').style.display='none'; };

let touchStart=null;
cv.addEventListener('touchstart',e=>{ const t=e.changedTouches[0]; touchStart={x:t.clientX,y:t.clientY,t:Date.now()}; },{passive:true});
cv.addEventListener('touchend',e=>{
  const t=e.changedTouches[0]; const dx=t.clientX-touchStart.x, dy=t.clientY-touchStart.y, dt=Date.now()-touchStart.t;
  const adx=Math.abs(dx), ady=Math.abs(dy);
  if(ady>40 && dt<250){ hardDrop(); return; }
  if(adx<10 && ady<10 && dt<220){ rotate(); return; }
},{passive:true});

/* fallback swipe left/right if no tilt */
cv.addEventListener('touchmove',e=>{
  if(useTilt) return;
  const t=e.changedTouches[0]; const dx=t.clientX-touchStart.x;
  if(Math.abs(dx)>22){ move(dx>0?1:-1); touchStart.x=t.clientX; }
},{passive:true});

/* ----------- game loop ----------- */
let piece=spawn();
let lines=0; const scoreEl=document.getElementById('score');
let dropEvery=900, last=0, acc=0;

function move(dir){ if(!collide(board,piece.shape,piece.x+dir,piece.y)){ piece.x+=dir; vibrate(8); } }
function rotate(){ if(tryRotate(piece,1)) vibrate(10); }
function softDrop(){ if(!collide(board,piece.shape,piece.x,piece.y+1)){ piece.y++; return true; } return false; }
function hardDrop(){ let moved=false; while(softDrop()) moved=true; tick(true); }
function vibrate(ms){ if(navigator.vibrate) navigator.vibrate(ms); }

function tick(lockNow=false){
  if(!lockNow && !collide(board,piece.shape,piece.x,piece.y+1)){ piece.y++; return; }
  // lock
  merge(board,piece); vibrate(30);
  const c=clearLines(); if(c){ lines+=c; scoreEl.textContent='Lines: '+lines; vibrate(60); dropEvery=Math.max(300,dropEvery-40*c); }
  piece=spawn();
  if(collide(board,piece.shape,piece.x,piece.y)){ // game over
    board=emptyBoard(); lines=0; dropEvery=900; scoreEl.textContent='Lines: 0';
  }
}

function update(t){
  const dt=t-last; last=t; acc+=dt;

  // handle tilt as repeated moves (DAS/ARR)
  if(useTilt){
    const thr=6; const dir = gamma>thr ? 1 : (gamma<-thr ? -1 : 0);
    if(dir){
      if(dir!==lastDir){ move(dir); nextMoveAt=t+DAS; lastDir=dir; }
      else if(t>=nextMoveAt){ move(dir); nextMoveAt=t+ARR; }
    }else{ lastDir=0; nextMoveAt=0; }
  }

  if(acc>=dropEvery){ acc%=dropEvery; tick(false); }
  draw();
  requestAnimationFrame(update);
}
requestAnimationFrame(update);
</script>
