<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Make 24 | Kapework</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=DM+Sans:wght@400;500;700&family=Space+Mono:wght@700&display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-tap-highlight-color: transparent;
        }

        :root {
            --cyan: #22d3ee;
            --cyan-dark: #0891b2;
            --cyan-glow: rgba(34, 211, 238, 0.3);
            --bg: #0f172a;
            --card-bg: #1e293b;
            --card-border: #334155;
            --text: #f1f5f9;
            --text-muted: #94a3b8;
            --success: #10b981;
            --error: #ef4444;
            --warning: #f59e0b;
            --gold: #fbbf24;
        }

        html, body {
            height: 100%;
            overflow: hidden;
        }

        body {
            font-family: 'DM Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg);
            color: var(--text);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100dvh;
            padding: 16px;
            padding-bottom: env(safe-area-inset-bottom, 16px);
        }

        /* Header */
        .header {
            width: 100%;
            max-width: 400px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px 0;
            margin-bottom: 24px;
        }

        .puzzle-number {
            font-family: 'Space Mono', monospace;
            font-size: 1.5rem;
            font-weight: 700;
            color: var(--cyan);
            cursor: pointer;
            transition: opacity 0.2s;
        }

        .puzzle-number:hover {
            opacity: 0.8;
        }

        .header-right {
            display: flex;
            align-items: center;
            gap: 16px;
        }

        .undo-btn {
            font-size: 1.5rem;
            color: var(--text-muted);
            background: none;
            border: none;
            cursor: pointer;
            opacity: 0;
            transition: opacity 0.2s, color 0.2s;
            padding: 4px;
            pointer-events: none;
        }

        .undo-btn.visible {
            opacity: 0.6;
            pointer-events: auto;
        }

        .undo-btn.visible:hover {
            opacity: 1;
            color: var(--cyan);
        }

        .undo-btn.visible:active {
            transform: scale(0.9);
        }

        .streak-display {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 1.25rem;
            font-weight: 700;
        }

        .streak-display .fire {
            font-size: 1.5rem;
        }

        .freeze-indicator {
            font-size: 1rem;
            margin-left: 4px;
            opacity: 0.8;
        }

        /* Game Container - centered vertically, shifted up */
        .game-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            width: 100%;
            max-width: 400px;
            position: relative;
            margin-top: -80px; /* Shift up more to center visually */
        }

        /* Current Result Display - only shown when down to 1 card */
        .result-display {
            font-family: 'Space Mono', monospace;
            font-size: 3.5rem;
            font-weight: 700;
            color: var(--text);
            height: 60px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: color 0.3s, transform 0.2s, opacity 0.3s;
            margin-bottom: 24px;
            opacity: 0;
        }

        .result-display.visible {
            opacity: 1;
        }

        .result-display.success {
            color: var(--success);
            transform: scale(1.1);
        }

        .result-display.error {
            color: var(--error);
        }

        /* Diamond Grid Layout - WIDER spread, LARGER tiles */
        .diamond-grid {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            grid-template-rows: 1fr 1fr 1fr;
            gap: 12px;
            width: 320px;
            height: 320px;
            position: relative;
        }

        /* Grid slot positions */
        .slot {
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .slot.top {
            grid-column: 2;
            grid-row: 1;
        }

        .slot.left {
            grid-column: 1;
            grid-row: 2;
        }

        .slot.right {
            grid-column: 3;
            grid-row: 2;
        }

        .slot.bottom {
            grid-column: 2;
            grid-row: 3;
        }

        /* Cards - LARGER with bigger font */
        .card {
            width: 96px;
            height: 96px;
            background: var(--card-bg);
            border: 2px solid var(--card-border);
            border-radius: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-family: 'Space Mono', monospace;
            font-size: 2.75rem;
            font-weight: 700;
            color: var(--text);
            cursor: pointer;
            transition: transform 0.15s ease, border-color 0.15s ease, box-shadow 0.15s ease;
            -webkit-user-select: none;
            user-select: none;
        }

        .card:active {
            transform: scale(0.95);
        }

        .card.selected {
            border-color: var(--cyan);
            box-shadow: 0 0 24px var(--cyan-glow);
            transform: scale(1.08);
        }

        .card.selected.first {
            border-color: var(--cyan);
        }

        .card.selected.second {
            border-color: var(--warning);
            box-shadow: 0 0 24px rgba(245, 158, 11, 0.3);
        }

        .card.used {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.8);
        }

        /* Centered Operators Overlay - semi-transparent to see tiles */
        .operators-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(15, 23, 42, 0.4);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 50;
        }

        .operators-overlay.show {
            display: flex;
        }

        .operators-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            grid-template-rows: 1fr 1fr;
            gap: 12px;
            padding: 14px;
            background: rgba(30, 41, 59, 0.75);
            border-radius: 20px;
            border: 1px solid rgba(51, 65, 85, 0.6);
        }

        .op-btn {
            width: 54px;
            height: 54px;
            border-radius: 50%;
            border: 2px solid var(--cyan);
            background: rgba(30, 41, 59, 0.9);
            color: var(--text);
            font-size: 1.5rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .op-btn:hover {
            background: rgba(34, 211, 238, 0.2);
            transform: scale(1.1);
        }

        .op-btn:active {
            transform: scale(0.95);
        }

        /* Attempts dots - subtle at bottom */
        .attempts {
            position: fixed;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            justify-content: center;
        }

        .attempt-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--card-border);
            transition: background 0.3s;
        }

        .attempt-dot.used {
            background: var(--error);
        }

        .attempt-dot.success {
            background: var(--success);
        }

        /* Message overlay */
        .message {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: var(--card-bg);
            border: 2px solid var(--cyan);
            border-radius: 16px;
            padding: 32px;
            text-align: center;
            z-index: 100;
            max-width: 90%;
            width: 320px;
            box-shadow: 0 0 40px var(--cyan-glow);
            display: none;
        }

        .message.show {
            display: block;
            animation: popIn 0.3s ease;
        }

        @keyframes popIn {
            from {
                opacity: 0;
                transform: translate(-50%, -50%) scale(0.8);
            }
            to {
                opacity: 1;
                transform: translate(-50%, -50%) scale(1);
            }
        }

        .message h2 {
            font-size: 1.5rem;
            margin-bottom: 8px;
        }

        .message h2.perfect {
            color: var(--gold);
        }

        .message p {
            color: var(--text-muted);
            margin-bottom: 16px;
        }

        .message .stats {
            font-family: 'Space Mono', monospace;
            font-size: 1.25rem;
            margin: 16px 0;
        }

        .message .btn {
            margin-top: 8px;
        }

        .btn {
            padding: 12px 24px;
            border-radius: 8px;
            border: none;
            font-family: 'DM Sans', sans-serif;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.15s ease;
        }

        .btn-primary {
            background: var(--cyan);
            color: var(--bg);
        }

        .btn-primary:hover {
            background: var(--cyan-dark);
        }

        .btn-secondary {
            background: var(--card-bg);
            color: var(--text);
            border: 1px solid var(--card-border);
            margin-left: 8px;
        }

        /* Archive Modal */
        .modal-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.85);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 200;
            padding: 16px;
        }

        .modal-overlay.show {
            display: flex;
        }

        .modal {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            max-width: 360px;
            width: 100%;
            max-height: 80vh;
            overflow-y: auto;
        }

        .modal h2 {
            text-align: center;
            margin-bottom: 16px;
            color: var(--cyan);
        }

        .archive-list {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 8px;
        }

        .archive-item {
            aspect-ratio: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            font-family: 'Space Mono', monospace;
            font-size: 0.875rem;
            cursor: pointer;
            transition: all 0.15s;
        }

        .archive-item:hover {
            border-color: var(--cyan);
        }

        .archive-item.completed {
            background: rgba(16, 185, 129, 0.2);
            border-color: var(--success);
        }

        .archive-item.failed {
            background: rgba(239, 68, 68, 0.2);
            border-color: var(--error);
        }

        .archive-item.today {
            border-color: var(--cyan);
            box-shadow: 0 0 10px var(--cyan-glow);
        }

        .modal-close {
            display: block;
            width: 100%;
            margin-top: 16px;
            padding: 12px;
            background: var(--bg);
            border: 1px solid var(--card-border);
            border-radius: 8px;
            color: var(--text);
            font-size: 1rem;
            cursor: pointer;
        }

        /* Confetti */
        .confetti-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1000;
            overflow: hidden;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            opacity: 0;
        }

        @keyframes confetti-fall {
            0% {
                transform: translateY(-100px) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Archive mode indicator */
        .archive-banner {
            background: var(--warning);
            color: var(--bg);
            padding: 8px 16px;
            border-radius: 8px;
            font-size: 0.875rem;
            font-weight: 600;
            position: fixed;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            display: none;
            z-index: 10;
        }

        .archive-banner.show {
            display: block;
        }

    </style>
</head>
<body>
    <div class="header">
        <div class="puzzle-number" id="puzzleNumber" title="Tap for archive">#â€”</div>
        <div class="header-right">
            <button class="undo-btn" id="undoBtn" title="Undo">â†¶</button>
            <div class="streak-display">
                <span class="fire">ðŸ”¥</span>
                <span id="streakCount">0</span>
                <span class="freeze-indicator" id="freezeIndicator"></span>
            </div>
        </div>
    </div>

    <div class="archive-banner" id="archiveBanner">
        ðŸ“… Archive Mode
    </div>

    <div class="game-container">
        <div class="result-display" id="resultDisplay">â€”</div>

        <div class="diamond-grid" id="diamondGrid">
            <div class="slot top" id="slot0"></div>
            <div class="slot left" id="slot1"></div>
            <div class="slot right" id="slot2"></div>
            <div class="slot bottom" id="slot3"></div>
        </div>
    </div>

    <!-- Operators appear centered when 2 cards selected -->
    <div class="operators-overlay" id="operatorsOverlay">
        <div class="operators-grid">
            <button class="op-btn" data-op="+">+</button>
            <button class="op-btn" data-op="-">âˆ’</button>
            <button class="op-btn" data-op="*">Ã—</button>
            <button class="op-btn" data-op="/">Ã·</button>
        </div>
    </div>

    <div class="attempts" id="attempts">
        <div class="attempt-dot"></div>
        <div class="attempt-dot"></div>
        <div class="attempt-dot"></div>
        <div class="attempt-dot"></div>
    </div>


    <div class="message" id="successMessage">
        <h2 id="successTitle">ðŸŽ‰ Nice!</h2>
        <p id="successSubtitle">You made 24!</p>
        <div class="stats" id="successStats"></div>
        <button class="btn btn-primary" id="shareBtn">Share</button>
        <button class="btn btn-secondary" id="closeSuccessBtn">Close</button>
    </div>

    <div class="message" id="failMessage">
        <h2>ðŸ˜¢ Out of attempts</h2>
        <p>Better luck tomorrow!</p>
        <div class="stats" id="failStats"></div>
        <button class="btn btn-primary" id="failShareBtn">Share</button>
        <button class="btn btn-secondary" id="closeFailBtn">Close</button>
    </div>

    <div class="modal-overlay" id="archiveModal">
        <div class="modal">
            <h2>ðŸ“… Archive</h2>
            <div class="archive-list" id="archiveList"></div>
            <button class="modal-close" id="closeArchive">Close</button>
        </div>
    </div>

    <div class="confetti-container" id="confetti"></div>

    <script>
        // Supabase config
        const SUPABASE_URL = 'https://fimsbfcvavpehryvvcho.supabase.co';
        const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImZpbXNiZmN2YXZwZWhyeXZ2Y2hvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NTUzOTEwMDMsImV4cCI6MjA3MDk2NzAwM30.6uAm_bDPN9aetYaKWA7zCvS8XDEVhmKKxA7RA7YK4JQ';

        // Constants
        const STORAGE_KEY = 'make24_v4';
        const MAX_ATTEMPTS = 4;
        const ARCHIVE_DAYS = 30;
        const STREAK_FREEZE_INTERVAL = 7;
        const PERFECT_MOVES = 3;

        // Game state (persisted per device)
        let gameState = {
            deviceId: null,
            streak: 0,
            freezes: 0,
            lastPlayedDate: null,
            history: {}, // { puzzleNum: { completed: bool, attempts: num, moves: num } }
        };

        let currentPuzzle = {
            numbers: [],
            puzzleNum: 0,
            date: null,
            isArchive: false
        };

        let playState = {
            cards: [], // { value, used, slot }
            selected: [], // indices
            attempts: 0,
            moves: 0, // counts ALL moves including undos
            cardStates: [], // for undo - stores previous card states
            completed: false
        };

        // Seeded RNG (Mulberry32)
        function mulberry32(seed) {
            return function() {
                let t = seed += 0x6D2B79F5;
                t = Math.imul(t ^ t >>> 15, t | 1);
                t ^= t + Math.imul(t ^ t >>> 7, t | 61);
                return ((t ^ t >>> 14) >>> 0) / 4294967296;
            };
        }

        // Get puzzle number from date
        function getPuzzleNumber(date) {
            const epoch = new Date('2025-01-01T00:00:00Z');
            const diff = date - epoch;
            return Math.floor(diff / (24 * 60 * 60 * 1000)) + 1;
        }

        // Get date from puzzle number
        function getDateFromPuzzleNumber(num) {
            const epoch = new Date('2025-01-01T00:00:00Z');
            return new Date(epoch.getTime() + (num - 1) * 24 * 60 * 60 * 1000);
        }

        // Get today's puzzle number (UTC)
        function getTodayPuzzleNumber() {
            const now = new Date();
            const utcDate = new Date(Date.UTC(now.getUTCFullYear(), now.getUTCMonth(), now.getUTCDate()));
            return getPuzzleNumber(utcDate);
        }

        // Generate 4 numbers for a puzzle
        function generatePuzzle(puzzleNum) {
            const rng = mulberry32(puzzleNum * 12345);
            const numbers = [];
            for (let i = 0; i < 4; i++) {
                numbers.push(Math.floor(rng() * 9) + 1); // 1-9
            }
            return numbers;
        }

        // Device ID
        function getDeviceId() {
            let id = localStorage.getItem('make24_device_id');
            if (!id) {
                id = 'dev_' + Math.random().toString(36).substr(2, 9) + Date.now().toString(36);
                localStorage.setItem('make24_device_id', id);
            }
            return id;
        }

        // Load/save state
        function loadState() {
            try {
                const saved = localStorage.getItem(STORAGE_KEY);
                if (saved) {
                    gameState = { ...gameState, ...JSON.parse(saved) };
                }
            } catch (e) {
                console.error('Failed to load state:', e);
            }
            gameState.deviceId = getDeviceId();
        }

        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(gameState));
            } catch (e) {
                console.error('Failed to save state:', e);
            }
        }

        // Streak management
        function updateStreak() {
            const today = getTodayPuzzleNumber();
            const yesterday = today - 1;
            
            if (gameState.lastPlayedDate === today) {
                // Already played today
                return;
            }
            
            if (gameState.lastPlayedDate === yesterday) {
                // Consecutive day - streak continues
            } else if (gameState.lastPlayedDate === yesterday - 1 && gameState.freezes > 0) {
                // Missed one day but have freeze
                gameState.freezes--;
                saveState();
            } else if (gameState.lastPlayedDate && gameState.lastPlayedDate < yesterday) {
                // Streak broken
                gameState.streak = 0;
                saveState();
            }
            
            updateStreakDisplay();
        }

        function incrementStreak() {
            gameState.streak++;
            gameState.lastPlayedDate = currentPuzzle.puzzleNum;
            
            // Award freeze every 7 days
            if (gameState.streak > 0 && gameState.streak % STREAK_FREEZE_INTERVAL === 0) {
                gameState.freezes++;
            }
            
            saveState();
            updateStreakDisplay();
        }

        function updateStreakDisplay() {
            document.getElementById('streakCount').textContent = gameState.streak;
            const freezeEl = document.getElementById('freezeIndicator');
            freezeEl.textContent = gameState.freezes > 0 ? 'â„ï¸'.repeat(Math.min(gameState.freezes, 3)) : '';
        }

        // Initialize puzzle
        function initPuzzle(puzzleNum, isArchive = false) {
            // Close any open messages first
            document.getElementById('successMessage').classList.remove('show');
            document.getElementById('failMessage').classList.remove('show');
            hideOperators();
            
            currentPuzzle.puzzleNum = puzzleNum;
            currentPuzzle.numbers = generatePuzzle(puzzleNum);
            currentPuzzle.isArchive = isArchive;
            currentPuzzle.date = getDateFromPuzzleNumber(puzzleNum);
            
            // Reset play state first
            playState.attempts = 0;
            playState.moves = 0;
            playState.completed = false;
            
            // Check history
            const history = gameState.history[puzzleNum];
            if (history) {
                playState.attempts = history.attempts || 0;
                if (history.completed) {
                    playState.completed = true;
                    playState.moves = history.moves || 0;
                } else if (history.attempts >= MAX_ATTEMPTS) {
                    playState.completed = true;
                }
            }
            
            resetPlay();
            updateUI();
        }

        function resetPlay() {
            playState.cards = currentPuzzle.numbers.map((v, i) => ({
                value: v,
                used: false,
                slot: i
            }));
            playState.selected = [];
            playState.cardStates = [];
            
            renderCards();
            hideOperators();
            updateResult();
        }

        // Render cards into grid slots
        function renderCards() {
            const slots = ['slot0', 'slot1', 'slot2', 'slot3'];
            
            slots.forEach((slotId, i) => {
                const slot = document.getElementById(slotId);
                slot.innerHTML = '';
                
                const cardData = playState.cards.find(c => c.slot === i && !c.used);
                if (cardData) {
                    const card = document.createElement('div');
                    card.className = 'card';
                    card.textContent = formatNumber(cardData.value);
                    card.dataset.index = playState.cards.indexOf(cardData);
                    
                    const cardIndex = playState.cards.indexOf(cardData);
                    if (playState.selected.includes(cardIndex)) {
                        card.classList.add('selected');
                        if (playState.selected[0] === cardIndex) {
                            card.classList.add('first');
                        } else {
                            card.classList.add('second');
                        }
                    }
                    
                    card.addEventListener('click', () => selectCard(cardIndex));
                    slot.appendChild(card);
                }
            });
        }

        function formatNumber(n) {
            if (Number.isInteger(n)) return n.toString();
            // Show fractions nicely
            const rounded = Math.round(n * 100) / 100;
            if (Number.isInteger(rounded)) return rounded.toString();
            return rounded.toFixed(2).replace(/\.?0+$/, '');
        }

        function selectCard(index) {
            if (playState.completed) return;
            if (playState.cards[index].used) return;
            
            const pos = playState.selected.indexOf(index);
            if (pos !== -1) {
                // Deselect
                playState.selected.splice(pos, 1);
                hideOperators();
            } else if (playState.selected.length < 2) {
                playState.selected.push(index);
                if (playState.selected.length === 2) {
                    showOperators();
                }
            }
            
            renderCards();
            
            // Request motion permission on first interaction (iOS requires user gesture)
            // Do this after selection logic so it doesn't interfere
            maybeRequestMotion();
        }

        function showOperators() {
            document.getElementById('operatorsOverlay').classList.add('show');
        }

        function hideOperators() {
            document.getElementById('operatorsOverlay').classList.remove('show');
        }

        function applyOperation(op) {
            if (playState.selected.length !== 2 || playState.completed) return;
            
            const [i, j] = playState.selected;
            const a = playState.cards[i].value;
            const b = playState.cards[j].value;
            
            let result;
            switch (op) {
                case '+': result = a + b; break;
                case '-': result = a - b; break;
                case '*': result = a * b; break;
                case '/': 
                    if (b === 0) return;
                    result = a / b;
                    break;
            }
            
            // Save state for undo (deep copy)
            playState.cardStates.push(JSON.parse(JSON.stringify(playState.cards)));
            
            // Mark cards as used
            playState.cards[i].used = true;
            playState.cards[j].used = true;
            
            // Find empty slot (prefer first card's slot)
            const emptySlot = playState.cards[i].slot;
            
            // Create new card
            playState.cards.push({
                value: result,
                used: false,
                slot: emptySlot
            });
            
            playState.selected = [];
            playState.moves++; // Count as a move
            
            hideOperators();
            renderCards();
            updateResult();
            
            // Check for win/lose
            checkGameState();
        }

        function undo() {
            if (playState.cardStates.length === 0 || playState.completed) return;
            
            // Restore previous state
            playState.cards = playState.cardStates.pop();
            playState.selected = [];
            playState.moves++; // Undo counts as a move!
            
            hideOperators();
            renderCards();
            updateResult();
        }

        function updateResult() {
            const remaining = playState.cards.filter(c => !c.used);
            const display = document.getElementById('resultDisplay');
            
            if (remaining.length === 1) {
                const val = remaining[0].value;
                display.textContent = formatNumber(val);
                display.classList.add('visible');
                if (Math.abs(val - 24) < 0.0001) {
                    display.classList.add('success');
                    display.classList.remove('error');
                } else {
                    display.classList.remove('success');
                    display.classList.add('error');
                }
            } else {
                display.textContent = '';
                display.classList.remove('visible', 'success', 'error');
            }
            
            // Update undo button visibility
            updateUndoButton();
        }
        
        function updateUndoButton() {
            const undoBtn = document.getElementById('undoBtn');
            if (playState.cardStates.length > 0 && !playState.completed) {
                undoBtn.classList.add('visible');
            } else {
                undoBtn.classList.remove('visible');
            }
        }

        function checkGameState() {
            const remaining = playState.cards.filter(c => !c.used);
            
            if (remaining.length === 1) {
                const val = remaining[0].value;
                
                if (Math.abs(val - 24) < 0.0001) {
                    handleWin();
                } else {
                    handleWrongAnswer();
                }
            }
        }

        function handleWin() {
            playState.completed = true;
            playState.attempts++;
            
            // Update history
            gameState.history[currentPuzzle.puzzleNum] = {
                completed: true,
                attempts: playState.attempts,
                moves: playState.moves
            };
            
            // Update streak only for today's puzzle
            if (!currentPuzzle.isArchive) {
                incrementStreak();
            }
            
            saveState();
            trackPlay(true);
            
            updateAttempts();
            showConfetti();
            
            // Check for perfect game
            const isPerfect = playState.moves === PERFECT_MOVES;
            const title = document.getElementById('successTitle');
            const subtitle = document.getElementById('successSubtitle');
            
            if (isPerfect) {
                title.textContent = 'â­ Perfect!';
                title.classList.add('perfect');
                subtitle.textContent = 'Solved in just 3 moves!';
            } else {
                title.textContent = 'ðŸŽ‰ Nice!';
                title.classList.remove('perfect');
                subtitle.textContent = 'You made 24!';
            }
            
            const stats = document.getElementById('successStats');
            stats.innerHTML = `Moves: ${playState.moves}<br>Attempts: ${playState.attempts}/${MAX_ATTEMPTS}`;
            
            setTimeout(() => {
                document.getElementById('successMessage').classList.add('show');
            }, 500);
        }

        function handleWrongAnswer() {
            playState.attempts++;
            
            // Update history
            if (!gameState.history[currentPuzzle.puzzleNum]) {
                gameState.history[currentPuzzle.puzzleNum] = { completed: false, attempts: 0 };
            }
            gameState.history[currentPuzzle.puzzleNum].attempts = playState.attempts;
            saveState();
            
            updateAttempts();
            
            if (playState.attempts >= MAX_ATTEMPTS) {
                // Out of attempts
                playState.completed = true;
                trackPlay(false);
                
                const stats = document.getElementById('failStats');
                stats.innerHTML = `The numbers were: ${currentPuzzle.numbers.join(', ')}`;
                
                setTimeout(() => {
                    document.getElementById('failMessage').classList.add('show');
                }, 500);
            } else {
                // Reset for next attempt - moves continue to accumulate
                setTimeout(() => {
                    playState.cards = currentPuzzle.numbers.map((v, i) => ({
                        value: v,
                        used: false,
                        slot: i
                    }));
                    playState.selected = [];
                    playState.cardStates = [];
                    renderCards();
                    updateResult();
                }, 800);
            }
        }

        function updateAttempts() {
            const dots = document.querySelectorAll('.attempt-dot');
            dots.forEach((dot, i) => {
                dot.classList.remove('used', 'success');
                if (i < playState.attempts) {
                    if (i === playState.attempts - 1 && playState.completed && 
                        gameState.history[currentPuzzle.puzzleNum]?.completed) {
                        dot.classList.add('success');
                    } else {
                        dot.classList.add('used');
                    }
                }
            });
        }

        function updateUI() {
            document.getElementById('puzzleNumber').textContent = `#${currentPuzzle.puzzleNum}`;
            document.getElementById('archiveBanner').classList.toggle('show', currentPuzzle.isArchive);
            updateStreakDisplay();
            updateAttempts();
        }

        // Confetti
        function showConfetti() {
            const container = document.getElementById('confetti');
            const colors = ['#22d3ee', '#10b981', '#f59e0b', '#ef4444', '#8b5cf6', '#fbbf24'];
            
            for (let i = 0; i < 60; i++) {
                const confetti = document.createElement('div');
                confetti.className = 'confetti';
                confetti.style.left = Math.random() * 100 + '%';
                confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
                confetti.style.animation = `confetti-fall ${1.5 + Math.random()}s ease-out forwards`;
                confetti.style.animationDelay = Math.random() * 0.5 + 's';
                confetti.style.borderRadius = Math.random() > 0.5 ? '50%' : '2px';
                confetti.style.width = (6 + Math.random() * 8) + 'px';
                confetti.style.height = (6 + Math.random() * 8) + 'px';
                container.appendChild(confetti);
            }
            
            setTimeout(() => {
                container.innerHTML = '';
            }, 3000);
        }

        // Share
        function generateShareText() {
            const won = gameState.history[currentPuzzle.puzzleNum]?.completed;
            const isPerfect = won && playState.moves === PERFECT_MOVES;
            
            let emoji = won ? (isPerfect ? 'â­' : 'âœ…') : 'âŒ';
            
            let text = `Make 24 #${currentPuzzle.puzzleNum} ${emoji}\n`;
            
            if (won) {
                if (isPerfect) {
                    text += `Perfect! 3 moves\n`;
                } else {
                    text += `Moves: ${playState.moves} | Attempts: ${playState.attempts}/${MAX_ATTEMPTS}\n`;
                }
            } else {
                text += `${playState.attempts}/${MAX_ATTEMPTS} attempts\n`;
            }
            
            text += `ðŸ”¥ Streak: ${gameState.streak}\n`;
            text += `kapework.com/apps/make24`;
            
            return text;
        }

        function share() {
            const text = generateShareText();
            
            if (navigator.share) {
                navigator.share({ text }).catch(() => {
                    copyToClipboard(text);
                });
            } else {
                copyToClipboard(text);
            }
        }

        function copyToClipboard(text) {
            navigator.clipboard.writeText(text).then(() => {
                alert('Copied to clipboard!');
            }).catch(() => {
                alert(text);
            });
        }

        // Archive
        function showArchive() {
            const modal = document.getElementById('archiveModal');
            const list = document.getElementById('archiveList');
            list.innerHTML = '';
            
            const today = getTodayPuzzleNumber();
            
            for (let i = 0; i < ARCHIVE_DAYS; i++) {
                const num = today - i;
                if (num < 1) continue;
                
                const item = document.createElement('div');
                item.className = 'archive-item';
                item.textContent = num;
                
                const history = gameState.history[num];
                if (history?.completed) {
                    item.classList.add('completed');
                } else if (history?.attempts >= MAX_ATTEMPTS) {
                    item.classList.add('failed');
                }
                
                if (num === today) {
                    item.classList.add('today');
                }
                
                item.addEventListener('click', () => {
                    modal.classList.remove('show');
                    initPuzzle(num, num !== today);
                });
                
                list.appendChild(item);
            }
            
            modal.classList.add('show');
        }

        // Track play to Supabase
        async function trackPlay(success) {
            try {
                const payload = {
                    slug: `make24-${currentPuzzle.puzzleNum}`,
                    device_id: gameState.deviceId,
                    metadata: {
                        success: success,
                        attempts: playState.attempts,
                        moves: playState.moves,
                        numbers: currentPuzzle.numbers,
                        isArchive: currentPuzzle.isArchive,
                        streak: gameState.streak,
                        perfect: success && playState.moves === PERFECT_MOVES
                    }
                };
                
                console.log('Tracking play to Supabase:', payload);
                
                const response = await fetch(`${SUPABASE_URL}/rest/v1/plays`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'apikey': SUPABASE_KEY,
                        'Authorization': `Bearer ${SUPABASE_KEY}`,
                        'Prefer': 'return=representation'
                    },
                    body: JSON.stringify(payload)
                });
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('Supabase error:', response.status, errorText);
                } else {
                    const result = await response.json();
                    console.log('Supabase success:', result);
                }
            } catch (e) {
                console.error('Failed to track play:', e);
            }
        }

        // Shake to undo (using DeviceMotion API)
        let lastShakeTime = 0;
        let shakeEnabled = false;
        const SHAKE_THRESHOLD = 25; // Higher threshold for more deliberate shakes
        const SHAKE_TIMEOUT = 800;
        let lastX = 0, lastY = 0, lastZ = 0;

        function handleMotion(event) {
            if (!shakeEnabled || playState.completed) return;
            
            const acc = event.accelerationIncludingGravity;
            if (!acc || acc.x === null) return;
            
            const x = acc.x;
            const y = acc.y;
            const z = acc.z;
            
            // Calculate change in acceleration
            const deltaX = Math.abs(x - lastX);
            const deltaY = Math.abs(y - lastY);
            const deltaZ = Math.abs(z - lastZ);
            
            lastX = x;
            lastY = y;
            lastZ = z;
            
            const totalDelta = deltaX + deltaY + deltaZ;
            const now = Date.now();
            
            if (totalDelta > SHAKE_THRESHOLD && now - lastShakeTime > SHAKE_TIMEOUT) {
                lastShakeTime = now;
                console.log('Shake detected! Delta:', totalDelta);
                undo();
            }
        }

        async function requestMotionPermission() {
            if (shakeEnabled) return true;
            
            try {
                if (typeof DeviceMotionEvent !== 'undefined' && 
                    typeof DeviceMotionEvent.requestPermission === 'function') {
                    // iOS 13+ requires permission
                    const response = await DeviceMotionEvent.requestPermission();
                    if (response === 'granted') {
                        window.addEventListener('devicemotion', handleMotion);
                        shakeEnabled = true;
                        console.log('Motion permission granted');
                        return true;
                    } else {
                        console.log('Motion permission denied');
                        return false;
                    }
                } else if ('DeviceMotionEvent' in window) {
                    // Non-iOS or older iOS - no permission needed
                    window.addEventListener('devicemotion', handleMotion);
                    shakeEnabled = true;
                    console.log('Motion events enabled (no permission needed)');
                    return true;
                }
            } catch (e) {
                console.error('Motion permission error:', e);
            }
            return false;
        }

        // Request motion permission on first card click (user gesture required for iOS)
        let motionPermissionRequested = false;
        function maybeRequestMotion() {
            if (!motionPermissionRequested && 'DeviceMotionEvent' in window) {
                motionPermissionRequested = true;
                requestMotionPermission();
            }
        }

        // Event listeners
        document.querySelectorAll('.op-btn').forEach(btn => {
            btn.addEventListener('click', () => applyOperation(btn.dataset.op));
        });

        document.getElementById('undoBtn').addEventListener('click', undo);

        // Close operators overlay when clicking outside
        document.getElementById('operatorsOverlay').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                playState.selected = [];
                hideOperators();
                renderCards();
            }
        });

        document.getElementById('puzzleNumber').addEventListener('click', showArchive);
        document.getElementById('closeArchive').addEventListener('click', () => {
            document.getElementById('archiveModal').classList.remove('show');
        });
        
        document.getElementById('shareBtn').addEventListener('click', share);
        document.getElementById('failShareBtn').addEventListener('click', share);
        
        document.getElementById('closeSuccessBtn').addEventListener('click', () => {
            document.getElementById('successMessage').classList.remove('show');
        });
        document.getElementById('closeFailBtn').addEventListener('click', () => {
            document.getElementById('failMessage').classList.remove('show');
        });

        // Close modals on overlay click
        document.getElementById('archiveModal').addEventListener('click', (e) => {
            if (e.target === e.currentTarget) {
                e.currentTarget.classList.remove('show');
            }
        });

        // Initialize
        loadState();
        updateStreak();
        initPuzzle(getTodayPuzzleNumber(), false);
        
        // For non-iOS devices, try to enable motion right away
        if (!('ontouchstart' in window)) {
            // Desktop - likely no motion support, but try anyway
            if ('DeviceMotionEvent' in window && typeof DeviceMotionEvent.requestPermission !== 'function') {
                window.addEventListener('devicemotion', handleMotion);
                shakeEnabled = true;
            }
        }
    </script>
</body>
</html>
